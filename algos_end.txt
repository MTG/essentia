{
    "RhythmExtractor2013": {
        "inputs": {
            "_signal": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "maxTempo": [
                "the fastest tempo to detect [bpm]", 
                "\"[60,250]208"
            ], 
            "method": [
                "the method used for beat tracking", 
                "\"{multifeature,degara}\"multifeature\""
            ], 
            "minTempo": [
                "the slowest tempo to detect [bpm]", 
                "\"[40,180]40"
            ]
        }, 
        "source": "algorithms/rhythm/rhythmextractor2013.cpp", 
        "outputs": {
            "_confidence": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_ticks": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_estimates": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_bpm": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_bpmIntervals": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/rhythm/rhythmextractor2013.h", 
        "has_streaming": true
    }, 
    "RhythmDescriptors": {
        "inputs": {
            "_signal": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/extractor/rhythmdescriptors.cpp", 
        "outputs": {
            "_secondPeakSpread": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_ticks": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_firstPeakBPM": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_bpm": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_firstPeakWeight": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_secondPeakBPM": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_bpmIntervals": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_estimates": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_firstPeakSpread": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_secondPeakWeight": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/extractor/rhythmdescriptors.h", 
        "has_streaming": true
    }, 
    "Vibrato": {
        "inputs": {
            "_pitch": {
                "type": "std::vector<Real>", 
                "name": "pitch", 
                "description": "the pitch trajectory [Hz]."
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "sample rate of the input pitch contour", 
                "\"(0,inf)44100.0/128.0"
            ], 
            "minFrequency": [
                "minimum considered vibrato frequency [Hz]", 
                "\"(0,inf)4.0"
            ], 
            "maxFrequency": [
                "maximum considered vibrato frequency [Hz]", 
                "\"(0,inf)8.0"
            ], 
            "minExtend": [
                "minimum considered vibrato extend [cents]", 
                "\"(0,inf)50.0"
            ], 
            "maxExtend": [
                "maximum considered vibrato extend [cents]", 
                "\"(0,inf)250.0"
            ]
        }, 
        "source": "algorithms/tonal/vibrato.cpp", 
        "outputs": {
            "_vibExtend": {
                "type": "std::vector<Real>", 
                "name": "vibratoExtend", 
                "description": "estimated vibrato frquency [Hz]; zero if no vibrato was detected.\")"
            }, 
            "_vibFrequency": {
                "type": "std::vector<Real>", 
                "name": "vibratoFrequency", 
                "description": "estimated vibrato frquency [Hz]; zero if no vibrato was detected."
            }
        }, 
        "header": "algorithms/tonal/vibrato.h", 
        "has_streaming": true
    }, 
    "HPCP": {
        "inputs": {
            "_frequencies": {
                "type": "std::vector<Real>", 
                "name": "frequencies", 
                "description": "the frequencies of the spectral peaks [Hz]"
            }, 
            "_magnitudes": {
                "type": "std::vector<Real>", 
                "name": "magnitudes", 
                "description": "the magnitudes of the spectral peaks"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "referenceFrequency": [
                "the reference frequency for semitone index calculation, corresponding to A3 [Hz]", 
                "\"(0,inf)440.0"
            ], 
            "bandPreset": [
                "enables whether to use a band preset", 
                "\"{true,false}true"
            ], 
            "nonLinear": [
                "enables whether to apply a Jordi non-linear post-processing function to the output", 
                "\"{true,false}false"
            ], 
            "splitFrequency": [
                "the split frequency for low and high bands, not used if bandPreset is false [Hz]", 
                "\"(0,inf)500.0"
            ], 
            "normalized": [
                "whether to normalize the HPCP vector", 
                "\"{true,false}true"
            ], 
            "maxFrequency": [
                "the maximum frequency that contributes to the HPCP [Hz] (the difference between the max and split frequencies must not be less than 200.0 Hz)", 
                "\"(0,inf)5000.0"
            ], 
            "minFrequency": [
                "the minimum frequency that contributes to the HPCP [Hz] (the difference between the min and split frequencies must not be less than 200.0 Hz)", 
                "\"(0,inf)40.0"
            ], 
            "windowSize": [
                "the size, in semitones, of the window used for the weighting", 
                "\"(0,12]1.0"
            ], 
            "weightType": [
                "type of weighting function for determining frequency contribution", 
                "\"{none,cosine,squaredCosine}\"squaredCosine\""
            ], 
            "harmonics": [
                "number of harmonics for frequency contribution, 0 indicates exclusive fundamental frequency contribution", 
                "\"[0,inf)0"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "maxShifted": [
                "whether to shift the HPCP vector so that the maximum peak is at index 0", 
                "\"{true,false}false"
            ], 
            "size": [
                "the size of the output HPCP (must be a positive nonzero multiple of 12)", 
                "\"[12,inf)12"
            ]
        }, 
        "source": "algorithms/spectral/hpcp.cpp", 
        "outputs": {
            "_hpcp": {
                "type": "std::vector<Real>", 
                "name": "hpcp", 
                "description": "the resulting harmonic pitch class profile"
            }
        }, 
        "header": "algorithms/spectral/hpcp.h", 
        "has_streaming": true
    }, 
    "PitchContoursMonoMelody": {
        "inputs": {
            "_contoursStartTimes": {
                "type": "std::vector<Real>", 
                "name": "contoursStartTimes", 
                "description": "array of the start times of each contour [s]"
            }, 
            "_contoursBins": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "contoursBins", 
                "description": "array of frame-wise vectors of cent bin values representing each contour"
            }, 
            "_duration": {
                "type": "Real", 
                "name": "duration", 
                "description": "time duration of the input signal [s]"
            }, 
            "_contoursSaliences": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "contoursSaliences", 
                "description": "array of frame-wise vectors of pitch saliences representing each contour"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "referenceFrequency": [
                "the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin", 
                "\"(0,inf)55.0"
            ], 
            "filterIterations": [
                "number of interations for the octave errors / pitch outlier filtering process", 
                "\"[1,inf)3"
            ], 
            "binResolution": [
                "salience function bin resolution [cents]", 
                "\"(0,inf)10.0"
            ], 
            "guessUnvoiced": [
                "Estimate pitch for non-voiced segments by using non-salient contours when no salient ones are present in a frame", 
                "\"{false,true}false"
            ], 
            "maxFrequency": [
                "the minimum allowed frequency for salience function peaks (ignore contours with peaks above) [Hz]", 
                "\"[0,inf)20000.0"
            ], 
            "minFrequency": [
                "the minimum allowed frequency for salience function peaks (ignore contours with peaks below) [Hz]", 
                "\"[0,inf)80.0"
            ], 
            "hopSize": [
                "the hop size with which the pitch salience function was computed", 
                "\"(0,inf)128"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal (Hz)", 
                "\"(0,inf)44100."
            ]
        }, 
        "source": "algorithms/tonal/pitchcontoursmonomelody.cpp", 
        "outputs": {
            "_pitch": {
                "type": "std::vector<Real>", 
                "name": "melody) [Hz]", 
                "description": "melody) [Hz]"
            }, 
            "_pitchConfidence": {
                "type": "std::vector<Real>", 
                "name": "pitchConfidence", 
                "description": "confidence with which the pitch was detected"
            }
        }, 
        "header": "algorithms/tonal/pitchcontoursmonomelody.h", 
        "has_streaming": true
    }, 
    "FileOutputProxy": {
        "inputs": {}, 
        "has_standard": false, 
        "parameters": {
            "mode": [
                "output mode", 
                "\"{text,binary}\"text\""
            ], 
            "filename": [
                "the name of the output file", 
                "\"\"out.txt\""
            ]
        }, 
        "source": "algorithms/io/fileoutputproxy.cpp", 
        "outputs": {}, 
        "header": "algorithms/io/fileoutputproxy.h", 
        "has_streaming": true
    }, 
    "MaxToTotal": {
        "inputs": {
            "_envelope": {
                "type": "std::vector<Real>", 
                "name": "envelope", 
                "description": "the envelope of the signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/sfx/maxtototal.cpp", 
        "outputs": {
            "_maxToTotal": {
                "type": "Real", 
                "name": "maxToTotal", 
                "description": "the maximum amplitude position to total length ratio"
            }
        }, 
        "header": "algorithms/sfx/maxtototal.h", 
        "has_streaming": true
    }, 
    "HarmonicPeaks": {
        "inputs": {
            "_frequencies": {
                "type": "std::vector<Real>", 
                "name": "frequencies", 
                "description": "the frequencies of the spectral peaks [Hz] (ascending order)"
            }, 
            "_magnitudes": {
                "type": "std::vector<Real>", 
                "name": "magnitudes", 
                "description": "the magnitudes of the spectral peaks (ascending frequency order)"
            }, 
            "_pitch": {
                "type": "Real", 
                "name": "pitch", 
                "description": "an estimate of the fundamental frequency of the signal [Hz]"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "maxHarmonics": [
                "the number of harmonics to return including F0", 
                "\"[1,inf)20"
            ], 
            "tolerance": [
                "the allowed ratio deviation from ideal harmonics", 
                "\"(0,0.5)0.2"
            ]
        }, 
        "source": "algorithms/tonal/harmonicpeaks.cpp", 
        "outputs": {
            "_harmonicFrequencies": {
                "type": "std::vector<Real>", 
                "name": "harmonicFrequencies", 
                "description": "the frequencies of harmonic peaks [Hz]"
            }, 
            "_harmonicMagnitudes": {
                "type": "std::vector<Real>", 
                "name": "harmonicMagnitudes", 
                "description": "the magnitudes of harmonic peaks"
            }
        }, 
        "header": "algorithms/tonal/harmonicpeaks.h", 
        "has_streaming": true
    }, 
    "MaxMagFreq": {
        "inputs": {
            "_spectrum": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the input spectrum (must have more than 1 element)"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the audio sampling rate [Hz]", 
                "\"(0,inf)44100."
            ]
        }, 
        "source": "algorithms/spectral/maxmagfreq.cpp", 
        "outputs": {
            "_maxMagFreq": {
                "type": "Real", 
                "name": "maxMagFreq", 
                "description": "the frequency with the largest magnitude [Hz]"
            }
        }, 
        "header": "algorithms/spectral/maxmagfreq.h", 
        "has_streaming": true
    }, 
    "MaxFilter": {
        "inputs": {
            "_array": {
                "type": "vector<Real>", 
                "name": "signal", 
                "description": "signal to be filtered"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "width": [
                "the window size, has to be odd if the window is centered", 
                "\"[2,inf)3"
            ], 
            "causal": [
                "use casual filter (window is behind current element otherwise it is centered around)", 
                "\"{true,false}true"
            ]
        }, 
        "source": "algorithms/SuperFlux/filter/MaxFilter.cpp", 
        "outputs": {
            "_filtered": {
                "type": "vector<Real>", 
                "name": "signal", 
                "description": "filtered output"
            }
        }, 
        "header": "algorithms/SuperFlux/filter/MaxFilter.h", 
        "has_streaming": true
    }, 
    "StrongPeak": {
        "inputs": {
            "_spectrum": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the input spectrum (must be greater than one element and cannot contain negative values)"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/spectral/strongpeak.cpp", 
        "outputs": {
            "_strongPeak": {
                "type": "Real", 
                "name": "strongPeak", 
                "description": "the Strong Peak ratio"
            }
        }, 
        "header": "algorithms/spectral/strongpeak.h", 
        "has_streaming": true
    }, 
    "SpectralWhitening": {
        "inputs": {
            "_frequencies": {
                "type": "std::vector<Real>", 
                "name": "frequencies", 
                "description": "the spectral peaks' linear frequencies"
            }, 
            "_magnitudes": {
                "type": "std::vector<Real>", 
                "name": "magnitudes", 
                "description": "the spectral peaks' linear magnitudes"
            }, 
            "_spectrum": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the audio linear spectrum"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "maxFrequency": [
                "max frequency to apply whitening to [Hz]", 
                "\"(0,inf)5000.0"
            ]
        }, 
        "source": "algorithms/spectral/spectralwhitening.cpp", 
        "outputs": {
            "_magnitudesWhite": {
                "type": "std::vector<Real>", 
                "name": "magnitudes", 
                "description": "the whitened spectral peaks' linear magnitudes"
            }
        }, 
        "header": "algorithms/spectral/spectralwhitening.h", 
        "has_streaming": true
    }, 
    "SuperFluxNovelty": {
        "inputs": {
            "_bands": {
                "type": "std::vector< std::vector<Real> >", 
                "name": "bands", 
                "description": "the input bands spectrogram"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "binWidth": [
                "height(n of frequency bins) of the SuperFluxNoveltyFilter", 
                "\"[3,inf)3"
            ], 
            "frameWidth": [
                "differenciate with the N-th previous frame", 
                "\"(0,inf)2"
            ]
        }, 
        "source": "algorithms/SuperFlux/SuperFlux/SuperFluxNovelty.cpp", 
        "outputs": {
            "_diffs": {
                "type": "Real", 
                "name": "Differences", 
                "description": "SuperFluxNovelty input"
            }
        }, 
        "header": "algorithms/SuperFlux/SuperFlux/SuperFluxNovelty.h", 
        "has_streaming": true
    }, 
    "Larm": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the audio input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "attackTime": [
                "the attack time of the first order lowpass in the attack phase [ms]", 
                "\"[0,inf)10.0"
            ], 
            "power": [
                "the power used for averaging", 
                "\"(-inf,inf)1.5"
            ], 
            "releaseTime": [
                "the release time of the first order lowpass in the release phase [ms]", 
                "\"[0,inf)1500.0"
            ]
        }, 
        "source": "algorithms/temporal/larm.cpp", 
        "outputs": {
            "_larm": {
                "type": "Real", 
                "name": "larm", 
                "description": "the LARM loudness estimate [dB]"
            }
        }, 
        "header": "algorithms/temporal/larm.h", 
        "has_streaming": true
    }, 
    "StereoDemuxer": {
        "inputs": {
            "_audio": {
                "type": "StereoSample", 
                "name": "the input stereo signal", 
                "description": "the input stereo signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/standard/stereodemuxer.cpp", 
        "outputs": {
            "_right": {
                "type": "AudioSample", 
                "name": "the right channel of the audio signal", 
                "description": "the right channel of the audio signal"
            }, 
            "_left": {
                "type": "AudioSample", 
                "name": "the left channel of the audio signal", 
                "description": "the left channel of the audio signal"
            }
        }, 
        "header": "algorithms/standard/stereodemuxer.h", 
        "has_streaming": true
    }, 
    "Inharmonicity": {
        "inputs": {
            "_frequencies": {
                "type": "std::vector<Real>", 
                "name": "frequencies", 
                "description": "the frequencies of the harmonic peaks [Hz] (in ascending order)"
            }, 
            "_magnitudes": {
                "type": "std::vector<Real>", 
                "name": "magnitudes", 
                "description": "the magnitudes of the harmonic peaks (in frequency ascending order"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/tonal/inharmonicity.cpp", 
        "outputs": {
            "_inharmonicity": {
                "type": "Real", 
                "name": "inharmonicity", 
                "description": "the inharmonicity of the audio signal"
            }
        }, 
        "header": "algorithms/tonal/inharmonicity.h", 
        "has_streaming": true
    }, 
    "InstantPower": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/stats/instantpower.cpp", 
        "outputs": {
            "_power": {
                "type": "Real", 
                "name": "power", 
                "description": "the instant power of the input array"
            }
        }, 
        "header": "algorithms/stats/instantpower.h", 
        "has_streaming": true
    }, 
    "MonoLoader": {
        "inputs": {}, 
        "has_standard": true, 
        "parameters": {
            "downmix": [
                "the mixing type for stereo files", 
                "\"{left,right,mix}\"mix\""
            ], 
            "sampleRate": [
                "the desired output sampling rate [Hz]", 
                "\"(0,inf)44100."
            ], 
            "filename": [
                "the name of the file from which to read", 
                "\"Parameter::STRING"
            ]
        }, 
        "source": "algorithms/io/monoloader.cpp", 
        "outputs": {
            "_audio": {
                "type": "AudioSample", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/io/monoloader.h", 
        "has_streaming": true
    }, 
    "MultiPitch": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "referenceFrequency": [
                "the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin", 
                "\"(0,inf)55.0"
            ], 
            "minFrequency": [
                "the minimum allowed frequency for salience function peaks (ignore peaks below) [Hz]", 
                "\"[0,inf)80.0"
            ], 
            "binResolution": [
                "salience function bin resolution [cents]", 
                "\"(0,inf)10.0"
            ], 
            "frameSize": [
                "the frame size for computing pitch saliecnce", 
                "\"(0,inf)2048"
            ], 
            "magnitudeThreshold": [
                "spectral peak magnitude threshold (maximum allowed difference from the highest peak in dBs)", 
                "\"[0,inf) 40"
            ], 
            "maxFrequency": [
                "the maximum allowed frequency for salience function peaks (ignore peaks above) [Hz]", 
                "\"[0,inf)1760.0"
            ], 
            "hopSize": [
                "the hop size with which the pitch salience function was computed", 
                "\"(0,inf)128"
            ], 
            "numberHarmonics": [
                "number of considered harmonics", 
                "\"[1,inf)10"
            ], 
            "harmonicWeight": [
                "harmonic weighting parameter (weight decay ratio between two consequent harmonics, =1 for no decay)", 
                "\"(0,1)0.8"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "magnitudeCompression": [
                "magnitude compression parameter for the salience function (=0 for maximum compression, =1 for no compression)", 
                "\"(0,1]1.0"
            ]
        }, 
        "source": "algorithms/tonal/multipitch.cpp", 
        "outputs": {
            "_pitch": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "pitch", 
                "description": "the estimated pitch values [Hz]"
            }
        }, 
        "header": "algorithms/tonal/multipitch.h", 
        "has_streaming": false
    }, 
    "TuningFrequencyExtractor": {
        "inputs": {
            "_signal": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "frameSize": [
                "the frameSize for computing tuning frequency", 
                "\"(0,inf)4096"
            ], 
            "hopSize": [
                "the hopsize for computing tuning frequency", 
                "\"(0,inf)2048"
            ]
        }, 
        "source": "algorithms/extractor/tuningfrequencyextractor.cpp", 
        "outputs": {
            "_tuningFreq": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/extractor/tuningfrequencyextractor.h", 
        "has_streaming": true
    }, 
    "NoiseAdder": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "fixSeed": [
                "if true, 0 is used as the seed for generating random values", 
                "\"{true,false}false"
            ], 
            "level": [
                "power level of the noise generator [dB]", 
                "\"(-inf,0]-100"
            ]
        }, 
        "source": "algorithms/standard/noiseadder.cpp", 
        "outputs": {
            "_noise": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the output signal with the added noise"
            }
        }, 
        "header": "algorithms/standard/noiseadder.h", 
        "has_streaming": true
    }, 
    "MonoWriter": {
        "inputs": {
            "_audio": {
                "type": "AudioSample", 
                "name": "the input audio", 
                "description": "the input audio"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the audio sampling rate [Hz]", 
                "\",\"(0,inf)44100."
            ], 
            "format": [
                "the audio output format", 
                "\",\"{wav,aiff,mp3,ogg,flac}\"wav\""
            ], 
            "bitrate": [
                "the audio bit rate for compressed formats [kbps]", 
                "\""
            ], 
            "filename": [
                "the name of the encoded file", 
                "\"Parameter::STRING"
            ]
        }, 
        "source": "algorithms/io/monowriter.cpp", 
        "outputs": {}, 
        "header": "algorithms/io/monowriter.h", 
        "has_streaming": true
    }, 
    "RingBufferOutput": {
        "inputs": {
            "_input": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": false, 
        "parameters": {
            "bufferSize": [
                "the size of the ringbuffer", 
                "\"8192"
            ]
        }, 
        "source": "algorithms/io/ringbufferoutput.cpp", 
        "outputs": {}, 
        "header": "algorithms/io/ringbufferoutput.h", 
        "has_streaming": true
    }, 
    "AutoCorrelation": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the array to be analyzed"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "normalization": [
                "type of normalization to compute: either 'standard' (default) or 'unbiased'", 
                "\"{standard,unbiased}\"standard\""
            ]
        }, 
        "source": "algorithms/standard/autocorrelation.cpp", 
        "outputs": {
            "_correlation": {
                "type": "std::vector<Real>", 
                "name": "autoCorrelation", 
                "description": "the autocorrelation vector"
            }
        }, 
        "header": "algorithms/standard/autocorrelation.h", 
        "has_streaming": true
    }, 
    "DCT": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "outputSize": [
                "the number of output coefficients", 
                "\"[1,inf)10"
            ], 
            "inputSize": [
                "the size of the input array", 
                "\"[1,inf)10"
            ]
        }, 
        "source": "algorithms/standard/dct.cpp", 
        "outputs": {
            "_dct": {
                "type": "std::vector<Real>", 
                "name": "dct", 
                "description": "the discrete cosine transform of the input array"
            }
        }, 
        "header": "algorithms/standard/dct.h", 
        "has_streaming": true
    }, 
    "TempoTap": {
        "inputs": {
            "_featuresFrame": {
                "type": "std::vector<Real>", 
                "name": "featuresFrame", 
                "description": "input temporal features"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "frameSize": [
                "number of audio samples in a frame", 
                "\"(0,inf)256"
            ], 
            "maxTempo": [
                "fastest tempo allowed to be detected [bpm]", 
                "\"[60,250]208"
            ], 
            "minTempo": [
                "slowest tempo allowed to be detected [bpm]", 
                "\"[40,180]40"
            ], 
            "tempoHints": [
                "optional list of initial beat locations, to favor the detection of pre-determined tempo period and beats alignment [s]", 
                "\"std::vector<Real>()"
            ], 
            "frameHop": [
                "number of feature frames separating two evaluations", 
                "\"(0,inf)1024"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "numberFrames": [
                "number of feature frames to buffer on", 
                "\"(0,inf)1024"
            ]
        }, 
        "source": "algorithms/rhythm/tempotap.cpp", 
        "outputs": {
            "_phases": {
                "type": "std::vector<Real>", 
                "name": "in frames", 
                "description": "in frames"
            }, 
            "_periods": {
                "type": "std::vector<Real>", 
                "name": "in frames", 
                "description": "in frames"
            }
        }, 
        "header": "algorithms/rhythm/tempotap.h", 
        "has_streaming": true
    }, 
    "GeometricMean": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/stats/geometricmean.cpp", 
        "outputs": {
            "_geometricMean": {
                "type": "Real", 
                "name": "geometricMean", 
                "description": "the geometric mean of the input array"
            }
        }, 
        "header": "algorithms/stats/geometricmean.h", 
        "has_streaming": true
    }, 
    "MelBands": {
        "inputs": {
            "_spectrumInput": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the audio spectrum"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "numberBands": [
                "the number of output bands", 
                "\"(1,inf)24"
            ], 
            "highFrequencyBound": [
                "an upper-bound limit for the frequencies to be included in the bands", 
                "\"[0,inf)22050.0"
            ], 
            "sampleRate": [
                "the sample rate", 
                "\"(0,inf)44100."
            ], 
            "inputSize": [
                "the size of the spectrum", 
                "\"(1,inf)1025"
            ], 
            "lowFrequencyBound": [
                "a lower-bound limit for the frequencies to be included in the bands", 
                "\"[0,inf)0.0"
            ]
        }, 
        "source": "algorithms/spectral/melbands.cpp", 
        "outputs": {
            "_bandsOutput": {
                "type": "std::vector<Real>", 
                "name": "bands", 
                "description": "the energy in mel bands"
            }
        }, 
        "header": "algorithms/spectral/melbands.h", 
        "has_streaming": true
    }, 
    "PolarToCartesian": {
        "inputs": {
            "_magnitude": {
                "type": "std::vector<Real>", 
                "name": "magnitude", 
                "description": "the magnitude vector"
            }, 
            "_phase": {
                "type": "std::vector<Real>", 
                "name": "phase", 
                "description": "the phase vector"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/complex/polartocartesian.cpp", 
        "outputs": {
            "_complex": {
                "type": "std::vector<std::complex<Real> >", 
                "name": "complex", 
                "description": "the resulting complex vector"
            }
        }, 
        "header": "algorithms/complex/polartocartesian.h", 
        "has_streaming": true
    }, 
    "PitchMelodia": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "guessUnvoiced": [
                "estimate pitch for non-voiced segments by using non-salient contours when no salient ones are present in a frame", 
                "\"{false,true}false"
            ], 
            "referenceFrequency": [
                "the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin", 
                "\"(0,inf)55.0"
            ], 
            "filterIterations": [
                "number of iterations for the octave errors / pitch outlier filtering process", 
                "\"[1,inf)3"
            ], 
            "minDuration": [
                "the minimum allowed contour duration [ms]", 
                "\"(0,inf)100"
            ], 
            "binResolution": [
                "salience function bin resolution [cents]", 
                "\"(0,inf)10.0"
            ], 
            "frameSize": [
                "the frame size for computing pitch saliecnce", 
                "\"(0,inf)2048"
            ], 
            "magnitudeThreshold": [
                "spectral peak magnitude threshold (maximum allowed difference from the highest peak in dBs)", 
                "\"[0,inf) 40"
            ], 
            "peakFrameThreshold": [
                "per-frame salience threshold factor (fraction of the highest peak salience in a frame)", 
                "\"[0,1]0.9"
            ], 
            "maxFrequency": [
                "the minimum allowed frequency for salience function peaks (ignore contours with peaks above) [Hz]", 
                "\"[0,inf)20000.0"
            ], 
            "minFrequency": [
                "the minimum allowed frequency for salience function peaks (ignore contours with peaks below) [Hz]", 
                "\"[0,inf)40.0"
            ], 
            "hopSize": [
                "the hop size with which the pitch salience function was computed", 
                "\"(0,inf)128"
            ], 
            "numberHarmonics": [
                "number of considered harmonics", 
                "\"[1,inf)20"
            ], 
            "harmonicWeight": [
                "harmonic weighting parameter (weight decay ratio between two consequent harmonics, =1 for no decay)", 
                "\"(0,1)0.8"
            ], 
            "peakDistributionThreshold": [
                "allowed deviation below the peak salience mean over all frames (fraction of the standard deviation)", 
                "\"[0,2]0.9"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "pitchContinuity": [
                "pitch continuity cue (maximum allowed pitch change during 1 ms time period) [cents]", 
                "\"[0,inf)27.5625"
            ], 
            "magnitudeCompression": [
                "magnitude compression parameter for the salience function (=0 for maximum compression, =1 for no compression)", 
                "\"(0,1]1.0"
            ], 
            "timeContinuity": [
                "time continuity cue (the maximum allowed gap duration for a pitch contour) [ms]", 
                "\"(0,inf)100"
            ]
        }, 
        "source": "algorithms/tonal/pitchmelodia.cpp", 
        "outputs": {
            "_pitch": {
                "type": "std::vector<Real>", 
                "name": "pitch", 
                "description": "the estimated pitch values [Hz]"
            }, 
            "_pitchConfidence": {
                "type": "std::vector<Real>", 
                "name": "pitchConfidence", 
                "description": "confidence with which the pitch was detected"
            }
        }, 
        "header": "algorithms/tonal/pitchmelodia.h", 
        "has_streaming": true
    }, 
    "SpectralPeaks": {
        "inputs": {
            "_spectrum": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the input spectrum"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "orderBy": [
                "the ordering type of the outputted peaks (ascending by frequency or descending by magnitude)", 
                "\"{frequency,magnitude}\"frequency\""
            ], 
            "magnitudeThreshold": [
                "peaks below this given threshold are not outputted", 
                "\"(-inf,inf)0.0"
            ], 
            "minFrequency": [
                "the minimum frequency of the range to evaluate [Hz]", 
                "\"[0,inf)0.0"
            ], 
            "maxFrequency": [
                "the maximum frequency of the range to evaluate [Hz]", 
                "\"(0,inf)5000.0"
            ], 
            "maxPeaks": [
                "the maximum number of returned peaks", 
                "\"[1,inf)100"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ]
        }, 
        "source": "algorithms/spectral/spectralpeaks.cpp", 
        "outputs": {
            "_frequencies": {
                "type": "std::vector<Real>", 
                "name": "frequencies", 
                "description": "the frequencies of the spectral peaks [Hz]"
            }, 
            "_magnitudes": {
                "type": "std::vector<Real>", 
                "name": "magnitudes", 
                "description": "the magnitudes of the spectral peaks"
            }
        }, 
        "header": "algorithms/spectral/spectralpeaks.h", 
        "has_streaming": true
    }, 
    "PitchContoursMultiMelody": {
        "inputs": {
            "_contoursStartTimes": {
                "type": "std::vector<Real>", 
                "name": "contoursStartTimes", 
                "description": "array of the start times of each contour [s]"
            }, 
            "_contoursBins": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "contoursBins", 
                "description": "array of frame-wise vectors of cent bin values representing each contour"
            }, 
            "_duration": {
                "type": "Real", 
                "name": "duration", 
                "description": "time duration of the input signal [s]"
            }, 
            "_contoursSaliences": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "contoursSaliences", 
                "description": "array of frame-wise vectors of pitch saliences representing each contour"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "referenceFrequency": [
                "the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin", 
                "\"(0,inf)55.0"
            ], 
            "filterIterations": [
                "number of interations for the octave errors / pitch outlier filtering process", 
                "\"[1,inf)3"
            ], 
            "binResolution": [
                "salience function bin resolution [cents]", 
                "\"(0,inf)10.0"
            ], 
            "guessUnvoiced": [
                "Estimate pitch for non-voiced segments by using non-salient contours when no salient ones are present in a frame", 
                "\"{false,true}false"
            ], 
            "maxFrequency": [
                "the minimum allowed frequency for salience function peaks (ignore contours with peaks above) [Hz]", 
                "\"[0,inf)20000.0"
            ], 
            "minFrequency": [
                "the minimum allowed frequency for salience function peaks (ignore contours with peaks below) [Hz]", 
                "\"[0,inf)80.0"
            ], 
            "hopSize": [
                "the hop size with which the pitch salience function was computed", 
                "\"(0,inf)128"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal (Hz)", 
                "\"(0,inf)44100."
            ]
        }, 
        "source": "algorithms/tonal/pitchcontoursmultimelody.cpp", 
        "outputs": {
            "_pitch": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "melody) [Hz]", 
                "description": "melody) [Hz]"
            }
        }, 
        "header": "algorithms/tonal/pitchcontoursmultimelody.h", 
        "has_streaming": true
    }, 
    "OnsetDetectionGlobal": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100.0"
            ], 
            "hopSize": [
                "the hop size for computing onset detection function", 
                "\"(0,inf)512"
            ], 
            "method": [
                "the method used for onset detection", 
                "\"{infogain,beat_emphasis}\"infogain\""
            ], 
            "frameSize": [
                "the frame size for computing onset detection function", 
                "\"(0,inf)2048"
            ]
        }, 
        "source": "algorithms/rhythm/onsetdetectionglobal.cpp", 
        "outputs": {
            "_onsetDetections": {
                "type": "std::vector<Real>", 
                "name": "onsetDetections", 
                "description": "the frame-wise values of the detection function"
            }
        }, 
        "header": "algorithms/rhythm/onsetdetectionglobal.h", 
        "has_streaming": true
    }, 
    "BarkBands": {
        "inputs": {
            "_spectrumInput": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the input spectrum"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"[0,inf)44100."
            ], 
            "numberBands": [
                "the number of desired barkbands", 
                "\"[1,28]27"
            ]
        }, 
        "source": "algorithms/spectral/barkbands.cpp", 
        "outputs": {
            "_bandsOutput": {
                "type": "std::vector<Real>", 
                "name": "bands", 
                "description": "the energy of the bark bands"
            }
        }, 
        "header": "algorithms/spectral/barkbands.h", 
        "has_streaming": true
    }, 
    "MonoMixer": {
        "inputs": {
            "_inputAudio": {
                "type": "std::vector<StereoSample>", 
                "name": "audio", 
                "description": "the input stereo signal"
            }, 
            "_channels": {
                "type": "int", 
                "name": "numberChannels", 
                "description": "the number of channels of the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "type": [
                "the type of downmixing performed", 
                "\"{left,right,mix}\"mix\""
            ]
        }, 
        "source": "algorithms/standard/monomixer.cpp", 
        "outputs": {
            "_outputAudio": {
                "type": "std::vector<Real>", 
                "name": "audio", 
                "description": "the downmixed signal"
            }
        }, 
        "header": "algorithms/standard/monomixer.h", 
        "has_streaming": true
    }, 
    "ChordsDescriptors": {
        "inputs": {
            "_key": {
                "type": "std::string", 
                "name": "from A to G", 
                "description": "from A to G"
            }, 
            "_chords": {
                "type": "std::vector<std::string>", 
                "name": "chords", 
                "description": "the chord progression"
            }, 
            "_scale": {
                "type": "std::string", 
                "name": "scale", 
                "description": "the scale of the whole song (major or minor)"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/tonal/chordsdescriptors.cpp", 
        "outputs": {
            "_chordsHistogram": {
                "type": "std::vector<Real>", 
                "name": "chordsHistogram", 
                "description": "the normalized histogram of chords"
            }, 
            "_chordsKey": {
                "type": "std::string", 
                "name": "chordsKey", 
                "description": "the most frequent chord of the progression"
            }, 
            "_chordsScale": {
                "type": "std::string", 
                "name": "chordsScale", 
                "description": "the scale of the most frequent chord of the progression (either 'major' or 'minor')"
            }, 
            "_chordsChangesRate": {
                "type": "Real", 
                "name": "chordsChangesRate", 
                "description": "the rate at which chords change in the progression"
            }, 
            "_chordsNumberRate": {
                "type": "Real", 
                "name": "chordsNumberRate", 
                "description": "the ratio of different chords from the total number of chords in the progression"
            }
        }, 
        "header": "algorithms/tonal/chordsdescriptors.h", 
        "has_streaming": true
    }, 
    "OnsetDetection": {
        "inputs": {
            "_phase": {
                "type": "std::vector<Real>", 
                "name": "phase", 
                "description": "the phase vector corresponding to this spectrum--used only by the \\\"complex\\\" method"
            }, 
            "_spectrum": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the input spectrum"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100.0"
            ], 
            "method": [
                "the method used for onset detection", 
                "\"{hfc,complex,complex_phase,flux,melflux,rms}\"hfc\""
            ]
        }, 
        "source": "algorithms/rhythm/onsetdetection.cpp", 
        "outputs": {
            "_onsetDetection": {
                "type": "Real", 
                "name": "onsetDetection", 
                "description": "the value of the detection function in the current frame"
            }
        }, 
        "header": "algorithms/rhythm/onsetdetection.h", 
        "has_streaming": true
    }, 
    "Variance": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/stats/variance.cpp", 
        "outputs": {
            "_variance": {
                "type": "Real", 
                "name": "variance", 
                "description": "the variance of the input array"
            }
        }, 
        "header": "algorithms/stats/variance.h", 
        "has_streaming": true
    }, 
    "LPC": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "frame", 
                "description": "the input audio frame"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "type": [
                "the type of LPC (regular or warped)", 
                "\"{regular,warped}\"regular\""
            ], 
            "order": [
                "the order of the LPC analysis (typically [8,14])", 
                "\"[2,inf)10"
            ]
        }, 
        "source": "algorithms/temporal/lpc.cpp", 
        "outputs": {
            "_lpc": {
                "type": "std::vector<Real>", 
                "name": "lpc", 
                "description": "the LPC coefficients"
            }, 
            "_reflection": {
                "type": "std::vector<Real>", 
                "name": "reflection", 
                "description": "the reflection coefficients"
            }
        }, 
        "header": "algorithms/temporal/lpc.h", 
        "has_streaming": true
    }, 
    "OddToEvenHarmonicEnergyRatio": {
        "inputs": {
            "_frequencies": {
                "type": "std::vector<Real>", 
                "name": "frequencies", 
                "description": "the frequencies of the harmonic peaks (at least two frequencies in frequency ascending order)"
            }, 
            "_magnitudes": {
                "type": "std::vector<Real>", 
                "name": "magnitudes", 
                "description": "the magnitudes of the harmonic peaks (at least two magnitudes in frequency ascending order)"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/tonal/oddtoevenharmonicenergyratio.cpp", 
        "outputs": {
            "_oddtoevenharmonicenergyratio": {
                "type": "Real", 
                "name": "oddToEvenHarmonicEnergyRatio", 
                "description": "the ratio between the odd and even harmonic energies of the given harmonic peaks"
            }
        }, 
        "header": "algorithms/tonal/oddtoevenharmonicenergyratio.h", 
        "has_streaming": true
    }, 
    "LogAttackTime": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal envelope (must be non-empty)"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the audio sampling rate [Hz]", 
                "\"(0,inf)44100."
            ], 
            "startAttackThreshold": [
                "the percentage of the input signal envelope at which the starting point of the attack is considered", 
                "\"[0,1]0.2"
            ], 
            "stopAttackThreshold": [
                "the percentage of the input signal envelope at which the ending point of the attack is considered", 
                "\"[0,1]0.9"
            ]
        }, 
        "source": "algorithms/sfx/logattacktime.cpp", 
        "outputs": {
            "_logAttackTime": {
                "type": "Real", 
                "name": "logAttackTime", 
                "description": "the log (base 10) of the attack time [log10(s)]"
            }
        }, 
        "header": "algorithms/sfx/logattacktime.h", 
        "has_streaming": true
    }, 
    "SuperFluxExtractor": {
        "inputs": {
            "_signal": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "ratioThreshold": [
                "ratio threshold for peak-picking compared to novelty_signal/novelty_average, 0  disable it ,  for low energy onsets", 
                "\"[0,inf)16."
            ], 
            "frameSize": [
                "the frame size for computing low level features", 
                "\"(0,inf)2048"
            ], 
            "combine": [
                "time threshold for double onsets detections (ms)", 
                "\",\"(0,inf)\",20.0"
            ], 
            "hopSize": [
                "the hop size for computing low level features", 
                "\"(0,inf)256"
            ], 
            "threshold": [
                "threshold for peak peaking compared to the difference of novelty_signal and average_signal ,  for peaking onsets in ambien noise", 
                "\",\"[0,inf)\",.05"
            ], 
            "sampleRate": [
                "the audio sampling rate", 
                "\"(0,inf)44100.0"
            ]
        }, 
        "source": "algorithms/SuperFlux/SuperFlux/SuperFluxExtractor.cpp", 
        "outputs": {
            "*vout": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_onsets": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/SuperFlux/SuperFlux/SuperFluxExtractor.h", 
        "has_streaming": true
    }, 
    "Slicer": {
        "inputs": {
            "_input": {
                "type": "Real", 
                "name": "the input signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "timeUnits": [
                "the units of time of the start and end times", 
                "\""
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\""
            ], 
            "startTimes": [
                "the list of start times for the slices", 
                " "
            ], 
            "endTimes": [
                "the list of end times for the slices you", 
                " "
            ]
        }, 
        "source": "algorithms/standard/slicer.cpp", 
        "outputs": {
            "_output": {
                "type": "std::vector<Real>", 
                "name": "the frames of the sliced input signal", 
                "description": "the frames of the sliced input signal"
            }
        }, 
        "header": "algorithms/standard/slicer.h", 
        "has_streaming": true
    }, 
    "Envelope": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "applyRectification": [
                "whether to apply rectification (envelope based on the absolute value of signal)", 
                "\"{true,false}true"
            ], 
            "sampleRate": [
                "the audio sampling rate [Hz]", 
                "\"(0,inf)44100."
            ], 
            "attackTime": [
                "the attack time of the first order lowpass in the attack phase [ms]", 
                "\"[0,inf)10.0"
            ], 
            "releaseTime": [
                "the release time of the first order lowpass in the release phase [ms]", 
                "\"[0,inf)1500.0"
            ]
        }, 
        "source": "algorithms/standard/envelope.cpp", 
        "outputs": {
            "_envelope": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the resulting envelope of the signal"
            }
        }, 
        "header": "algorithms/standard/envelope.h", 
        "has_streaming": true
    }, 
    "SpectralContrast": {
        "inputs": {
            "_spectrum": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the audio spectrum"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "neighbourRatio": [
                "the ratio of the bins in the sub band used to calculate the peak and valley", 
                "\"(0,1]0.4"
            ], 
            "frameSize": [
                "the size of the fft frames", 
                "\"[2,inf)2048"
            ], 
            "staticDistribution": [
                "the ratio of the bins to distribute equally", 
                "\"[0,1]0.15"
            ], 
            "numberBands": [
                "the number of bands in the filter", 
                "\"(0,inf)6"
            ], 
            "lowFrequencyBound": [
                "the lower bound of the lowest band", 
                "\"[0,inf)20."
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal", 
                "\"(0,inf)22050."
            ], 
            "highFrequencyBound": [
                "the upper bound of the highest band", 
                "\"(0,inf)11000."
            ]
        }, 
        "source": "algorithms/spectral/spectralcontrast.cpp", 
        "outputs": {
            "_valleys": {
                "type": "std::vector<Real>", 
                "name": "spectralValley", 
                "description": "the magnitudes of the valleys"
            }, 
            "_spectralcontrast": {
                "type": "std::vector<Real>", 
                "name": "spectralContrast", 
                "description": "the spectral contrast coefficients"
            }
        }, 
        "header": "algorithms/spectral/spectralcontrast.h", 
        "has_streaming": true
    }, 
    "SBic": {
        "inputs": {
            "_features": {
                "type": "TNT::Array2D<Real>", 
                "name": "and columns represent frames of audio)", 
                "description": "and columns represent frames of audio)"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "inc1": [
                "first pass increment [frames]", 
                "\"[1,inf)60"
            ], 
            "inc2": [
                "second pass increment [frames]", 
                "\"[1,inf)20"
            ], 
            "size1": [
                "first pass window size [frames]", 
                "\"[1,inf)300"
            ], 
            "size2": [
                "second pass window size [frames]", 
                "\"[1,inf)200"
            ], 
            "minLength": [
                "minimum length of a segment [frames]", 
                "\"[1,inf)10"
            ], 
            "cpw": [
                "complexity penalty weight", 
                "\"[0,inf)1.5"
            ]
        }, 
        "source": "algorithms/highlevel/sbic.cpp", 
        "outputs": {
            "_segmentation": {
                "type": "std::vector<Real>", 
                "name": "respectively)", 
                "description": "respectively)"
            }
        }, 
        "header": "algorithms/highlevel/sbic.h", 
        "has_streaming": true
    }, 
    "Intensity": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input audio signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the input audio sampling rate [Hz]", 
                "\"(0,inf)44100."
            ]
        }, 
        "source": "algorithms/highlevel/intensity.cpp", 
        "outputs": {
            "_intensity": {
                "type": "int", 
                "name": "intensity", 
                "description": "the intensity value"
            }
        }, 
        "header": "algorithms/highlevel/intensity.h", 
        "has_streaming": false
    }, 
    "Centroid": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "range": [
                "the range of the input array, used for normalizing the results", 
                "\"(0,inf)1.0"
            ]
        }, 
        "source": "algorithms/stats/centroid.cpp", 
        "outputs": {
            "_centroid": {
                "type": "Real", 
                "name": "centroid", 
                "description": "the centroid of the array"
            }
        }, 
        "header": "algorithms/stats/centroid.h", 
        "has_streaming": true
    }, 
    "TriangularBands": {
        "inputs": {
            "_spectrumInput": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the input spectrum (must be greater than size one)"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "frequencyBands": [
                "list of frequency ranges into which the spectrum is divided (these must be in ascending order and connot contain duplicates),", 
                "\""
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "log": [
                "taking log10 (1 + magnitude) in each band", 
                "\",\"{true,false}true"
            ]
        }, 
        "source": "algorithms/SuperFlux/filter/TriangularBands.cpp", 
        "outputs": {
            "_bandsOutput": {
                "type": "std::vector<Real>", 
                "name": "bands", 
                "description": "the energy in each band"
            }
        }, 
        "header": "algorithms/SuperFlux/filter/TriangularBands.h", 
        "has_streaming": true
    }, 
    "DerivativeSFX": {
        "inputs": {
            "_envelope": {
                "type": "std::vector<Real>", 
                "name": "envelope", 
                "description": "the envelope of the signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/sfx/derivativesfx.cpp", 
        "outputs": {
            "_derAvAfterMax": {
                "type": "Real", 
                "name": "derAvAfterMax", 
                "description": "the weighted average of the derivative after the maximum amplitude"
            }, 
            "_maxDerBeforeMax": {
                "type": "Real", 
                "name": "maxDerBeforeMax", 
                "description": "the maximum derivative before the maximum amplitude"
            }
        }, 
        "header": "algorithms/sfx/derivativesfx.h", 
        "has_streaming": true
    }, 
    "HarmonicBpm": {
        "inputs": {
            "_bpmCandidates": {
                "type": "std::vector<Real>", 
                "name": "bpms", 
                "description": "list of bpm candidates"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "threshold": [
                "bpm threshold below which greatest common divisors are discarded", 
                "\"[1,inf)20.0"
            ], 
            "tolerance": [
                "percentage tolerance to consider two bpms are equal or equal to a harmonic", 
                "\"[0,inf)5.0"
            ], 
            "bpm": [
                "the bpm used to find its harmonics", 
                "\"[1,inf)60"
            ]
        }, 
        "source": "algorithms/highlevel/harmonicbpm.cpp", 
        "outputs": {
            "_harmonicBpms": {
                "type": "std::vector<Real>", 
                "name": "harmonicBpms", 
                "description": "a list of bpms which are harmonically related to the bpm parameter"
            }
        }, 
        "header": "algorithms/highlevel/harmonicbpm.h", 
        "has_streaming": true
    }, 
    "VectorRealAccumulator": {
        "inputs": {
            "_value": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": false, 
        "parameters": {}, 
        "source": "algorithms/standard/vectorrealaccumulator.cpp", 
        "outputs": {
            "_array": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/standard/vectorrealaccumulator.h", 
        "has_streaming": true
    }, 
    "LowLevelSpectralExtractor": {
        "inputs": {
            "_signal": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the audio sampling rate", 
                "\"(0,inf)44100.0"
            ], 
            "frameSize": [
                "the frame size for computing low level features", 
                "\"(0,inf)2048"
            ], 
            "hopSize": [
                "the hop size for computing low level features", 
                "\"(0,inf)1024"
            ]
        }, 
        "source": "algorithms/extractor/lowlevelspectralextractor.cpp", 
        "outputs": {
            "_odd2even": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_bbands": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_silence30": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_mfccs": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_bbandsKurtosis": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_zeroCrossingRate": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_ebandMidHigh": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_rolloffValue": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_tristimulusValue": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_bbandsSpread": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_pitchValue": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_energyValue": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_inharmonicityValue": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_decreaseValue": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_bbandsSkewness": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_ebandLow": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_pitchSalienceValue": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_silence20": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_flatness": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_rmsValue": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_ebandMidLow": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_pitchConfidence": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_ebandHigh": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_hfcValue": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_silence60": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_crestValue": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_strongPeakValue": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_fluxValue": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_spectralComplexityValue": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/extractor/lowlevelspectralextractor.h", 
        "has_streaming": true
    }, 
    "Onsets": {
        "inputs": {
            "_weights": {
                "type": "std::vector<Real>", 
                "name": "must be the same as the first dimension of \\\"detections\\", 
                "description": "must be the same as the first dimension of \\\"detections\\"
            }, 
            "_detections": {
                "type": "TNT::Array2D<Real>", 
                "name": "detections", 
                "description": "matrix containing onset detection functions--rows represent the values of different detection functions and columns represent different frames of audio (i.e. detections[i][j] represents the value of the ith detection function for the jth frame of audio)"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "delay": [
                "the number of frames used to compute the threshold--size of short-onset filter", 
                "\"(0,inf)5"
            ], 
            "alpha": [
                "the proportion of the mean included to reject smaller peaks--filters very short onsets", 
                "\"[0,1]0.1"
            ], 
            "silenceThreshold": [
                "the threshold for silence", 
                "\"[0,1]0.020"
            ], 
            "frameRate": [
                "frames per second", 
                "\"(0,inf)44100.0/512.0"
            ]
        }, 
        "source": "algorithms/rhythm/onsets.cpp", 
        "outputs": {
            "_onsets": {
                "type": "std::vector<Real>", 
                "name": "onsets", 
                "description": "the onset times [s]"
            }
        }, 
        "header": "algorithms/rhythm/onsets.h", 
        "has_streaming": true
    }, 
    "HighPass": {
        "inputs": {
            "_x": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input audio signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "cutoffFrequency": [
                "the cutoff frequency for the filter [Hz]", 
                "\"(0,inf)1500."
            ]
        }, 
        "source": "algorithms/filters/highpass.cpp", 
        "outputs": {
            "_y": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the filtered signal"
            }
        }, 
        "header": "algorithms/filters/highpass.h", 
        "has_streaming": true
    }, 
    "Tristimulus": {
        "inputs": {
            "_frequencies": {
                "type": "std::vector<Real>", 
                "name": "frequencies", 
                "description": "the frequencies of the harmonic peaks ordered by frequency"
            }, 
            "_magnitudes": {
                "type": "std::vector<Real>", 
                "name": "magnitudes", 
                "description": "the magnitudes of the harmonic peaks ordered by frequency"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/tonal/tristimulus.cpp", 
        "outputs": {
            "_tristimulus": {
                "type": "std::vector<Real>", 
                "name": "tristimulus", 
                "description": "a three-element vector that measures the mixture of harmonics of the given spectrum"
            }
        }, 
        "header": "algorithms/tonal/tristimulus.h", 
        "has_streaming": true
    }, 
    "EffectiveDuration": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "thresholdRatio": [
                "the ratio of the envelope maximum to be used as the threshold", 
                "\"[0,1]0.4"
            ]
        }, 
        "source": "algorithms/temporal/effectiveduration.cpp", 
        "outputs": {
            "_effectiveDuration": {
                "type": "Real", 
                "name": "effectiveDuration", 
                "description": "the effective duration of the signal [s]"
            }
        }, 
        "header": "algorithms/temporal/effectiveduration.h", 
        "has_streaming": true
    }, 
    "Panning": {
        "inputs": {
            "_spectrumLeft": {
                "type": "std::vector<Real>", 
                "name": "spectrumLeft", 
                "description": "Left channel's spectrum"
            }, 
            "_spectrumRight": {
                "type": "std::vector<Real>", 
                "name": "spectrumRight", 
                "description": "Right channel's spectrum"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "averageFrames": [
                "number of frames to take into account for averaging", 
                "\"[0,inf)43"
            ], 
            "numCoeffs": [
                "number of coefficients used to define the panning curve at each frame", 
                "\"(0,inf)20"
            ], 
            "warpedPanorama": [
                "if true, warped panorama is applied, having more resolution in the center area", 
                "\"{false,true}true"
            ], 
            "numBands": [
                "number of mel bands", 
                "\"[1,inf)1"
            ], 
            "panningBins": [
                "size of the histogram of ratios (in bins)", 
                "\"(1,inf)512"
            ], 
            "sampleRate": [
                "audio sampling rate [Hz]", 
                "\"(0,inf)44100."
            ]
        }, 
        "source": "algorithms/spectral/panning.cpp", 
        "outputs": {
            "_panningCoeffs": {
                "type": "TNT::Array2D<Real>", 
                "name": "panningCoeffs", 
                "description": "Parameters that define the panning curve at each frame"
            }
        }, 
        "header": "algorithms/spectral/panning.h", 
        "has_streaming": true
    }, 
    "LowLevelSpectralEqloudExtractor": {
        "inputs": {
            "_signal": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the audio sampling rate", 
                "\"(0,inf)44100.0"
            ], 
            "frameSize": [
                "the frame size for computing low level features", 
                "\"(0,inf)2048"
            ], 
            "hopSize": [
                "the hop size for computing low level features", 
                "\"(0,inf)1024"
            ]
        }, 
        "source": "algorithms/extractor/lowlevelspectraleqloudextractor.cpp", 
        "outputs": {
            "_scentroid": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_sccontrast": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_kurtosis": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_scvalleys": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_spread": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_skewness": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_dissonanceValue": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/extractor/lowlevelspectraleqloudextractor.h", 
        "has_streaming": true
    }, 
    "PCA": {
        "inputs": {
            "_poolIn": {
                "type": "Pool", 
                "name": "poolIn", 
                "description": "the pool where to get the spectral contrast feature vectors"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "namespaceOut": [
                "will save to this namespace in poolOut", 
                "\"\"spectral contrast pca\""
            ], 
            "dimensions": [
                "number of dimension to reduce the input to", 
                "\"[0, inf)0"
            ], 
            "namespaceIn": [
                "will look for this namespace in poolIn", 
                "\"\"spectral contrast\""
            ]
        }, 
        "source": "algorithms/highlevel/pca.cpp", 
        "outputs": {
            "_poolOut": {
                "type": "Pool", 
                "name": "poolOut", 
                "description": "the pool where to store the transformed feature vectors"
            }
        }, 
        "header": "algorithms/highlevel/pca.h", 
        "has_streaming": false
    }, 
    "StartStopSilence": {
        "inputs": {
            "_frame": {
                "type": "std::vector<Real>", 
                "name": "frame", 
                "description": "the input audio frames"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "threshold": [
                "the threshold below which average energy is defined as silence [dB]", 
                "\"(-inf,0])-60"
            ]
        }, 
        "source": "algorithms/standard/startstopsilence.cpp", 
        "outputs": {
            "_stopSilenceSource": {
                "type": "int", 
                "name": "stopFrame", 
                "description": "number of the last non-silent frame"
            }, 
            "_startSilenceSource": {
                "type": "int", 
                "name": "startFrame", 
                "description": "number of the first non-silent frame"
            }
        }, 
        "header": "algorithms/standard/startstopsilence.h", 
        "has_streaming": true
    }, 
    "StrongDecay": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input audio signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ]
        }, 
        "source": "algorithms/sfx/strongdecay.cpp", 
        "outputs": {
            "_strongDecay": {
                "type": "Real", 
                "name": "strongDecay", 
                "description": "the strong decay"
            }
        }, 
        "header": "algorithms/sfx/strongdecay.h", 
        "has_streaming": true
    }, 
    "SingleBeatLoudness": {
        "inputs": {
            "_beat": {
                "type": "std::vector<AudioSample>", 
                "name": "beat", 
                "description": "the sliced beat"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "beatDuration": [
                "the size of the window in which the beat will be restricted [s]", 
                "\"(0,inf)0.05"
            ], 
            "frequencyBands": [
                "the bands", 
                "\"arrayToVector<Real>(defaultBands)"
            ], 
            "sampleRate": [
                "the audio sampling rate [Hz]", 
                "\"(0,inf)44100."
            ], 
            "beatWindowDuration": [
                "the size of the window in which to look for the beginning of the beat [s]", 
                "\"(0,inf)0.1"
            ], 
            "onsetStart": [
                "criteria for finding the start of the beat", 
                "\"{sumEnergy, peakEnergy}\"sumEnergy\""
            ]
        }, 
        "source": "algorithms/rhythm/singlebeatloudness.cpp", 
        "outputs": {
            "_loudnessBand": {
                "type": "std::vector<Real>", 
                "name": "loudnessBandRatio", 
                "description": "the beat's energy ratio on each band"
            }, 
            "_loudness": {
                "type": "Real", 
                "name": "loudness", 
                "description": "the beat's energy in the whole spectrum"
            }
        }, 
        "header": "algorithms/rhythm/singlebeatloudness.h", 
        "has_streaming": true
    }, 
    "AllPass": {
        "inputs": {
            "_x": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "cutoffFrequency": [
                "the cutoff frequency for the filter [Hz]", 
                "\"(0,inf)1500."
            ], 
            "order": [
                "the order of the filter", 
                "\"{1,2}1"
            ], 
            "bandwidth": [
                "the bandwidth of the filter [Hz] (used only for 2nd-order filters)", 
                "\"(0,inf)500."
            ]
        }, 
        "source": "algorithms/filters/allpass.cpp", 
        "outputs": {
            "_y": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the filtered signal"
            }
        }, 
        "header": "algorithms/filters/allpass.h", 
        "has_streaming": true
    }, 
    "AudioWriter": {
        "inputs": {
            "_audio": {
                "type": "StereoSample", 
                "name": "the input audio", 
                "description": "the input audio"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the audio sampling rate [Hz]", 
                "\",\"(0,inf)44100."
            ], 
            "format": [
                "the audio output format", 
                "\",\"{wav,aiff,mp3,ogg,flac}\"wav\""
            ], 
            "bitrate": [
                "the audio bit rate for compressed formats [kbps]", 
                "\""
            ], 
            "filename": [
                "the name of the encoded file", 
                "\"Parameter::STRING"
            ]
        }, 
        "source": "algorithms/io/audiowriter.cpp", 
        "outputs": {}, 
        "header": "algorithms/io/audiowriter.h", 
        "has_streaming": true
    }, 
    "Leq": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal (must be non-empty)"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/temporal/leq.cpp", 
        "outputs": {
            "_leq": {
                "type": "Real", 
                "name": "leq", 
                "description": "the equivalent sound level estimate"
            }
        }, 
        "header": "algorithms/temporal/leq.h", 
        "has_streaming": true
    }, 
    "PredominantMelody": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "voicingTolerance": [
                "allowed deviation below the average contour mean salience of all contours (fraction of the standard deviation)", 
                "\"[-1.0,1.4]0.2"
            ], 
            "referenceFrequency": [
                "the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin", 
                "\"(0,inf)55.0"
            ], 
            "filterIterations": [
                "number of iterations for the octave errors / pitch outlier filtering process", 
                "\"[1,inf)3"
            ], 
            "minDuration": [
                "the minimum allowed contour duration [ms]", 
                "\"(0,inf)100"
            ], 
            "binResolution": [
                "salience function bin resolution [cents]", 
                "\"(0,inf)10.0"
            ], 
            "frameSize": [
                "the frame size for computing pitch saliecnce", 
                "\"(0,inf)2048"
            ], 
            "magnitudeThreshold": [
                "spectral peak magnitude threshold (maximum allowed difference from the highest peak in dBs)", 
                "\"[0,inf) 40"
            ], 
            "peakFrameThreshold": [
                "per-frame salience threshold factor (fraction of the highest peak salience in a frame)", 
                "\"[0,1]0.9"
            ], 
            "maxFrequency": [
                "the minimum allowed frequency for salience function peaks (ignore contours with peaks above) [Hz]", 
                "\"[0,inf)20000.0"
            ], 
            "minFrequency": [
                "the minimum allowed frequency for salience function peaks (ignore contours with peaks below) [Hz]", 
                "\"[0,inf)80.0"
            ], 
            "guessUnvoiced": [
                "estimate pitch for non-voiced segments by using non-salient contours when no salient ones are present in a frame", 
                "\"{false,true}false"
            ], 
            "hopSize": [
                "the hop size with which the pitch salience function was computed", 
                "\"(0,inf)128"
            ], 
            "numberHarmonics": [
                "number of considered harmonics", 
                "\"[1,inf)20"
            ], 
            "harmonicWeight": [
                "harmonic weighting parameter (weight decay ratio between two consequent harmonics, =1 for no decay)", 
                "\"(0,1)0.8"
            ], 
            "peakDistributionThreshold": [
                "allowed deviation below the peak salience mean over all frames (fraction of the standard deviation)", 
                "\"[0,2]0.9"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "pitchContinuity": [
                "pitch continuity cue (maximum allowed pitch change during 1 ms time period) [cents]", 
                "\"[0,inf)27.5625"
            ], 
            "magnitudeCompression": [
                "magnitude compression parameter for the salience function (=0 for maximum compression, =1 for no compression)", 
                "\"(0,1]1.0"
            ], 
            "voiceVibrato": [
                "detect voice vibrato", 
                "\"{true,false}false"
            ], 
            "timeContinuity": [
                "time continuity cue (the maximum allowed gap duration for a pitch contour) [ms]", 
                "\"(0,inf)100"
            ]
        }, 
        "source": "algorithms/tonal/predominantmelody.cpp", 
        "outputs": {
            "_pitch": {
                "type": "std::vector<Real>", 
                "name": "pitch", 
                "description": "the estimated pitch values [Hz]"
            }, 
            "_pitchConfidence": {
                "type": "std::vector<Real>", 
                "name": "pitchConfidence", 
                "description": "confidence with which the pitch was detected"
            }
        }, 
        "header": "algorithms/tonal/predominantmelody.h", 
        "has_streaming": true
    }, 
    "Key": {
        "inputs": {
            "_pcp": {
                "type": "std::vector<Real>", 
                "name": "pcp", 
                "description": "the input pitch class profile"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "numHarmonics": [
                "number of harmonics that should contribute to the polyphonic profile (1 only considers the fundamental harmonic)", 
                "\"[1,inf)4"
            ], 
            "slope": [
                "value of the slope of the exponential harmonic contribution to the polyphonic profile", 
                "\"[0,inf)0.6"
            ], 
            "useThreeChords": [
                "consider only the 3 main triad chords of the key (T, D, SD) to build the polyphonic profiles", 
                "\"{true,false}true"
            ], 
            "usePolyphony": [
                "enables the use of polyphonic profiles to define key profiles (this includes the contributions from triads as well as pitch harmonics)", 
                "\"{true,false}true"
            ], 
            "profileType": [
                "the type of polyphic profile to use for correlation calculation", 
                "\"{diatonic,krumhansl,temperley,weichai,tonictriad,temperley2005,thpcp,shaath,gomez}\"temperley\""
            ], 
            "pcpSize": [
                "number of array elements used to represent a semitone times 12 (this parameter is only a hint, during computation, the size of the input PCP is used instead)", 
                "\"[12,inf)36"
            ]
        }, 
        "source": "algorithms/tonal/key.cpp", 
        "outputs": {
            "_key": {
                "type": "std::string", 
                "name": "from A to G", 
                "description": "from A to G"
            }, 
            "_strength": {
                "type": "Real", 
                "name": "strength", 
                "description": "the strength of the estimated key"
            }, 
            "_scale": {
                "type": "std::string", 
                "name": "scale", 
                "description": "the scale of the key (major or minor)"
            }, 
            "_firstToSecondRelativeStrength": {
                "type": "Real", 
                "name": "firstToSecondRelativeStrength", 
                "description": "the relative strength difference between the best estimate and second best estimate of the key"
            }
        }, 
        "header": "algorithms/tonal/key.h", 
        "has_streaming": true
    }, 
    "EqloudLoader": {
        "inputs": {}, 
        "has_standard": true, 
        "parameters": {
            "filename": [
                "the name of the file from which to read", 
                "\"Parameter::STRING"
            ], 
            "downmix": [
                "the mixing type for stereo files", 
                "\"{left,right,mix}\"mix\""
            ], 
            "replayGain": [
                "the value of the replayGain [dB] that should be used to normalize the signal [dB]", 
                "\"(-inf,inf)-6.0"
            ], 
            "startTime": [
                "the start time of the slice to be extracted [s]", 
                "\"[0,inf)0.0"
            ], 
            "sampleRate": [
                "the output sampling rate [Hz]", 
                "\"{32000,44100,48000}44100."
            ], 
            "endTime": [
                "the end time of the slice to be extracted [s]", 
                "\"[0,inf)1e6"
            ]
        }, 
        "source": "algorithms/io/eqloudloader.cpp", 
        "outputs": {
            "_audio": {
                "type": "AudioSample", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/io/eqloudloader.h", 
        "has_streaming": true
    }, 
    "YamlOutput": {
        "inputs": {
            "_pool": {
                "type": "Pool", 
                "name": "pool", 
                "description": "Pool to serialize into a YAML formatted file"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "format": [
                "whether to output data in JSON or YAML format", 
                "\"{json,yaml}\"yaml\""
            ], 
            "writeVersion": [
                "whether to write the essentia version to the output file", 
                "\"true"
            ], 
            "indent": [
                "(json only) how many characters to indent each line, or 0 for no newlines", 
                "\"4"
            ], 
            "doubleCheck": [
                "whether to double-check if the file has been correctly written to the disk", 
                "\"false"
            ], 
            "filename": [
                "output filename (use '-' to emit to stdout)", 
                "\"\"-\""
            ]
        }, 
        "source": "algorithms/io/yamloutput.cpp", 
        "outputs": {}, 
        "header": "algorithms/io/yamloutput.h", 
        "has_streaming": false
    }, 
    "BandReject": {
        "inputs": {
            "_x": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "cutoffFrequency": [
                "the cutoff frequency for the filter [Hz]", 
                "\"(0,inf)1500."
            ], 
            "bandwidth": [
                "the bandwidth of the filter [Hz]", 
                "\"(0,inf)500."
            ]
        }, 
        "source": "algorithms/filters/bandreject.cpp", 
        "outputs": {
            "_y": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the filtered signal"
            }
        }, 
        "header": "algorithms/filters/bandreject.h", 
        "has_streaming": true
    }, 
    "EqualLoudness": {
        "inputs": {
            "_x": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"{32000,44100,48000}44100."
            ]
        }, 
        "source": "algorithms/filters/equalloudness.cpp", 
        "outputs": {
            "_y": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the filtered signal"
            }
        }, 
        "header": "algorithms/filters/equalloudness.h", 
        "has_streaming": true
    }, 
    "Beatogram": {
        "inputs": {
            "_loudnessBandRatio": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "loudnessBandRatio", 
                "description": "matrix of loudness ratios at each band and beat"
            }, 
            "_loudness": {
                "type": "std::vector<Real>", 
                "name": "loudness", 
                "description": "the loudness at each beat"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "size": [
                "number of beats for dynamic filtering", 
                "\"[1,inf)16"
            ]
        }, 
        "source": "algorithms/experimental/beatogram.cpp", 
        "outputs": {
            "_beatogram": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "beatogram", 
                "description": "filtered matrix loudness"
            }
        }, 
        "header": "algorithms/experimental/beatogram.h", 
        "has_streaming": true
    }, 
    "WarpedAutoCorrelation": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the array to be analyzed"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the audio sampling rate [Hz]", 
                "\"(0,inf)44100."
            ], 
            "maxLag": [
                "the maximum lag for which the auto-correlation is computed (inclusive) (must be smaller than signal size) ", 
                "\"(0,inf)1"
            ]
        }, 
        "source": "algorithms/standard/warpedautocorrelation.cpp", 
        "outputs": {
            "_warpedAutoCorrelation": {
                "type": "std::vector<Real>", 
                "name": "warpedAutoCorrelation", 
                "description": "the warped auto-correlation vector"
            }
        }, 
        "header": "algorithms/standard/warpedautocorrelation.h", 
        "has_streaming": true
    }, 
    "ReplayGain": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input audio signal (must be longer than 0.05ms)"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the input audio signal [Hz]", 
                "\"(0,inf)44100."
            ]
        }, 
        "source": "algorithms/standard/replaygain.cpp", 
        "outputs": {
            "_gain": {
                "type": "Real", 
                "name": "replayGain", 
                "description": "the distance to the suitable average replay level (~-31dbB) defined by SMPTE [dB]"
            }
        }, 
        "header": "algorithms/standard/replaygain.h", 
        "has_streaming": true
    }, 
    "PitchFilterMakam": {
        "inputs": {
            "_energy": {
                "type": "std::vector<Real>", 
                "name": "energy", 
                "description": "vector of energy values for the input frames"
            }, 
            "_pitch": {
                "type": "std::vector<Real>", 
                "name": "pitch", 
                "description": "vector of pitch values for the input frames [Hz]"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "octaveFilter": [
                "enable global octave filter", 
                "\"{true,false}false"
            ], 
            "minChunkSize": [
                "minumum number of frames in non-zero pitch chunks", 
                "\"[0,inf) 10"
            ]
        }, 
        "source": "algorithms/tonal/pitchfiltermakam.cpp", 
        "outputs": {
            "_pitchFiltered": {
                "type": "std::vector<Real>", 
                "name": "pitchFiltered", 
                "description": "vector of corrected pitch values [Hz]"
            }
        }, 
        "header": "algorithms/tonal/pitchfiltermakam.h", 
        "has_streaming": true
    }, 
    "RealAccumulator": {
        "inputs": {
            "_value": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": false, 
        "parameters": {}, 
        "source": "algorithms/standard/realaccumulator.cpp", 
        "outputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/standard/realaccumulator.h", 
        "has_streaming": true
    }, 
    "Windowing": {
        "inputs": {
            "_frame": {
                "type": "std::vector<Real>", 
                "name": "frame", 
                "description": "the input audio frame"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "zeroPadding": [
                "the size of the zero-padding", 
                "\"[0,inf)0"
            ], 
            "type": [
                "the window type, which can be 'hamming', 'hann', 'triangular', 'square' or 'blackmanharrisXX'", 
                "\"{hamming,hann,triangular,square,blackmanharris62,blackmanharris70,blackmanharris74,blackmanharris92}\"hann\""
            ], 
            "zeroPhase": [
                "a boolean value that enables zero-phase windowing", 
                "\"{true,false}true"
            ], 
            "size": [
                "the window size", 
                "\"[2,inf)1024"
            ]
        }, 
        "source": "algorithms/standard/windowing.cpp", 
        "outputs": {
            "_windowedFrame": {
                "type": "std::vector<Real>", 
                "name": "frame", 
                "description": "the windowed audio frame"
            }
        }, 
        "header": "algorithms/standard/windowing.h", 
        "has_streaming": true
    }, 
    "BeatTrackerDegara": {
        "inputs": {
            "_signal": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "maxTempo": [
                "the fastest tempo to detect [bpm]", 
                "\"[60,250]208"
            ], 
            "minTempo": [
                "the slowest tempo to detect [bpm]", 
                "\"[40,180]40"
            ]
        }, 
        "source": "algorithms/rhythm/beattrackerdegara.cpp", 
        "outputs": {
            "_ticks": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/rhythm/beattrackerdegara.h", 
        "has_streaming": true
    }, 
    "IFFTW": {
        "inputs": {
            "_fft": {
                "type": "std::vector<std::complex<Real> >", 
                "name": "fft", 
                "description": "the input frame"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "size": [
                "the expected size of the input frame. This is purely optional and only targeted at optimizing the creation time of the FFT object", 
                "\"[1,inf)1024"
            ]
        }, 
        "source": "algorithms/standard/ifftw.cpp", 
        "outputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "frame", 
                "description": "the IFFT of the input frame"
            }
        }, 
        "header": "algorithms/standard/ifftw.h", 
        "has_streaming": true
    }, 
    "Energy": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/stats/energy.cpp", 
        "outputs": {
            "_energy": {
                "type": "Real", 
                "name": "energy", 
                "description": "the energy of the input array"
            }
        }, 
        "header": "algorithms/stats/energy.h", 
        "has_streaming": true
    }, 
    "PoolAggregator": {
        "inputs": {
            "_input": {
                "type": "Pool", 
                "name": "input", 
                "description": "the input pool"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "defaultStats": [
                "the default statistics to be computed for each descriptor in the input pool", 
                "\"defaultStats"
            ], 
            "exceptions": [
                "a mapping between descriptor names (no duplicates) and the types of statistics to be computed for those descriptors (e.g. { lowlevel.bpm : [min, max], lowlevel.gain : [var, min, dmean] })", 
                "\"std::map<std::string, std::vector<std::string> >()"
            ]
        }, 
        "source": "algorithms/stats/poolaggregator.cpp", 
        "outputs": {
            "_output": {
                "type": "Pool", 
                "name": "output", 
                "description": "a pool containing the aggregate values of the input pool"
            }
        }, 
        "header": "algorithms/stats/poolaggregator.h", 
        "has_streaming": true
    }, 
    "DCRemoval": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input audio signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "cutoffFrequency": [
                "the cutoff frequency for the filter [Hz]", 
                "\"(0,inf)40."
            ]
        }, 
        "source": "algorithms/filters/dcremoval.cpp", 
        "outputs": {
            "_signalDC": {
                "type": "std::vector<Real>", 
                "name": "with the DC component removed", 
                "description": "with the DC component removed"
            }
        }, 
        "header": "algorithms/filters/dcremoval.h", 
        "has_streaming": true
    }, 
    "EnergyBandRatio": {
        "inputs": {
            "_spectrum": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the input audio spectrum"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "startFrequency": [
                "the frequency from which to start summing the energy [Hz]", 
                "\"[0,inf)0.0"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "stopFrequency": [
                "the frequency up to which to sum the energy [Hz]", 
                "\"[0,inf)100.0"
            ]
        }, 
        "source": "algorithms/spectral/energybandratio.cpp", 
        "outputs": {
            "_energyBandRatio": {
                "type": "Real", 
                "name": "energyBandRatio", 
                "description": "the energy ratio of the specified band over the total energy"
            }
        }, 
        "header": "algorithms/spectral/energybandratio.h", 
        "has_streaming": true
    }, 
    "PitchSalienceFunctionPeaks": {
        "inputs": {
            "_salienceFunction": {
                "type": "std::vector<Real>", 
                "name": "salienceFunction", 
                "description": "the array of salience function values corresponding to cent frequency bins"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "maxFrequency": [
                "the maximum frequency to evaluate (ignore peaks above) [Hz]", 
                "\"[0,inf)1760.0"
            ], 
            "minFrequency": [
                "the minimum frequency to evaluate (ignore peaks below) [Hz]", 
                "\"[0,inf)55.0"
            ], 
            "binResolution": [
                "salience function bin resolution [cents]", 
                "\"(0,inf)10.0"
            ], 
            "referenceFrequency": [
                "the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin", 
                "\"(0,inf)55.0"
            ]
        }, 
        "source": "algorithms/tonal/pitchsaliencefunctionpeaks.cpp", 
        "outputs": {
            "_salienceValues": {
                "type": "std::vector<Real>", 
                "name": "salienceValues", 
                "description": "the values of salience function peaks"
            }, 
            "_salienceBins": {
                "type": "std::vector<Real>", 
                "name": "salienceBins", 
                "description": "the cent bins corresponding to salience function peaks"
            }
        }, 
        "header": "algorithms/tonal/pitchsaliencefunctionpeaks.h", 
        "has_streaming": true
    }, 
    "Spline": {
        "inputs": {
            "_xInput": {
                "type": "Real", 
                "name": "x", 
                "description": "the input coordinate (x-axis)"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "xPoints": [
                "the x-coordinates where data is specified (the points must be arranged in ascending order and cannot contain duplicates)", 
                "\"defaultPoints"
            ], 
            "type": [
                "the type of spline to be computed", 
                "\"{b,beta,quadratic}\"b\""
            ], 
            "beta2": [
                "the tension parameter", 
                "\"[0,inf)0.0"
            ], 
            "beta1": [
                "the skew or bias parameter (only available for type beta)", 
                "\"[0,inf]1.0"
            ], 
            "yPoints": [
                "the y-coordinates to be interpolated (i.e. the known data)", 
                "\"defaultPoints"
            ]
        }, 
        "source": "algorithms/standard/spline.cpp", 
        "outputs": {
            "_yOutput": {
                "type": "Real", 
                "name": "y", 
                "description": "the value of the spline at x"
            }
        }, 
        "header": "algorithms/standard/spline.h", 
        "has_streaming": true
    }, 
    "TonicIndianArtMusic": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "referenceFrequency": [
                "the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin", 
                "\"(0,inf)55.0"
            ], 
            "binResolution": [
                "salience function bin resolution [cents]", 
                "\"(0,inf)10.0"
            ], 
            "frameSize": [
                "the frame size for computing pitch saliecnce", 
                "\"(0,inf)2048"
            ], 
            "magnitudeThreshold": [
                "peak magnitude threshold (maximum allowed difference from the highest peak in dBs)", 
                "\"[0,inf) 40.0"
            ], 
            "maxTonicFrequency": [
                "the maximum allowed tonic frequency [Hz]", 
                "\"[0,inf)375.0"
            ], 
            "numberSaliencePeaks": [
                "number of top peaks of the salience function which should be considered for constructing histogram", 
                "\"[1, 15]5"
            ], 
            "hopSize": [
                "the hop size with which the pitch salience function was computed", 
                "\"(0,inf)512"
            ], 
            "numberHarmonics": [
                "number of considered hamonics", 
                "\"[1,inf)20"
            ], 
            "harmonicWeight": [
                "harmonic weighting parameter (weight decay ratio between two consequent harmonics, =1 for no decay)", 
                "\"(0,1)0.85"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "magnitudeCompression": [
                "magnitude compression parameter (=0 for maximum compression, =1 for no compression)", 
                "\"(0,1]1.0"
            ], 
            "minTonicFrequency": [
                "the minimum allowed tonic frequency [Hz]", 
                "\"[0,inf)100.0"
            ]
        }, 
        "source": "algorithms/tonal/tonicindianartmusic.cpp", 
        "outputs": {
            "_tonic": {
                "type": "Real", 
                "name": "tonic", 
                "description": "the estimated tonic frequency [Hz]"
            }
        }, 
        "header": "algorithms/tonal/tonicindianartmusic.h", 
        "has_streaming": false
    }, 
    "FlatnessDB": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/spectral/flatnessdb.cpp", 
        "outputs": {
            "_flatnessDB": {
                "type": "Real", 
                "name": "flatnessDB", 
                "description": "the flatness dB"
            }
        }, 
        "header": "algorithms/spectral/flatnessdb.h", 
        "has_streaming": true
    }, 
    "AudioOnsetsMarker": {
        "inputs": {
            "_input": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the output signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "type": [
                "the type of sound to be added on the event", 
                "\"{beep,noise}\"beep\""
            ], 
            "onsets": [
                "the list of onset locations [s]", 
                "\"std::vector<Real>()"
            ]
        }, 
        "source": "algorithms/io/audioonsetsmarker.cpp", 
        "outputs": {
            "_output": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal mixed with bursts at onset locations"
            }
        }, 
        "header": "algorithms/io/audioonsetsmarker.h", 
        "has_streaming": true
    }, 
    "GFCC": {
        "inputs": {
            "_spectrum": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the audio spectrum"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "lowFrequencyBound": [
                "the lower bound of the frequency range [Hz]", 
                "\"[0,inf)40."
            ], 
            "highFrequencyBound": [
                "the upper bound of the frequency range [Hz]", 
                "\"(0,inf)22050."
            ], 
            "numberBands": [
                "the number of bands in the filter", 
                "\"[1,inf)40"
            ], 
            "numberCoefficients": [
                "the number of output cepstrum coefficients", 
                "\"[1,inf)13"
            ]
        }, 
        "source": "algorithms/spectral/gfcc.cpp", 
        "outputs": {
            "_bands": {
                "type": "std::vector<Real>", 
                "name": "bands", 
                "description": "the energies in ERB bands"
            }, 
            "_gfcc": {
                "type": "std::vector<Real>", 
                "name": "gfcc", 
                "description": "the gammatone feature cepstrum coefficients"
            }
        }, 
        "header": "algorithms/spectral/gfcc.h", 
        "has_streaming": true
    }, 
    "Flatness": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/stats/flatness.cpp", 
        "outputs": {
            "_flatness": {
                "type": "Real", 
                "name": "flatness", 
                "description": "the flatness (ratio between the geometric and the arithmetic mean of the input array)"
            }
        }, 
        "header": "algorithms/stats/flatness.h", 
        "has_streaming": true
    }, 
    "TempoTapDegara": {
        "inputs": {
            "_onsetDetections": {
                "type": "std::vector<Real>", 
                "name": "onsetDetections", 
                "description": "the input frame-wise vector of onset detection values"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRateODF": [
                "the sampling rate of the onset detection function [Hz]", 
                "\"(0,inf)44100./512"
            ], 
            "resample": [
                "use upsampling of the onset detection function (may increase accuracy)", 
                "\"{none,x2,x3,x4}\"none\""
            ], 
            "maxTempo": [
                "fastest tempo allowed to be detected [bpm]", 
                "\"[60,250]208"
            ], 
            "minTempo": [
                "slowest tempo allowed to be detected [bpm]", 
                "\"[40,180]40"
            ]
        }, 
        "source": "algorithms/rhythm/tempotapdegara.cpp", 
        "outputs": {
            "_ticks": {
                "type": "std::vector<Real>", 
                "name": "ticks", 
                "description": "the list of resulting ticks [s]"
            }
        }, 
        "header": "algorithms/rhythm/tempotapdegara.h", 
        "has_streaming": true
    }, 
    "BpmHistogram": {
        "inputs": {
            "_signal": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": false, 
        "parameters": {
            "zeroPadding": [
                "zero padding factor to compute the fft [s]", 
                "\"[0,inf)0"
            ], 
            "tempoChange": [
                "the minimum length to consider a change in tempo as stable [s]", 
                "\"[0,inf)5."
            ], 
            "frameSize": [
                "the minimum length to compute the fft [s]", 
                "\"[1,inf)4.0"
            ], 
            "maxBpm": [
                "the maximum bpm to consider", 
                "\"(0,inf)560."
            ], 
            "bpm": [
                "bpm to induce a certain tempo tracking. Zero if unknown", 
                "\"[0,inf)0.0"
            ], 
            "frameRate": [
                "the sampling rate of the novelty curve [frame/s]", 
                "\"[1,inf)44100./512."
            ], 
            "overlap": [
                "the overlap factor", 
                "\"(0,inf)16"
            ], 
            "constantTempo": [
                "whether to consider constant tempo. Set to true when inducina specific tempo", 
                "\"{true,false}false"
            ], 
            "weightByMagnitude": [
                "whether to consider peaks' magnitude when building the histogram", 
                "\"{true,false}true"
            ], 
            "windowType": [
                "the window type to be used when computing the fft", 
                "\"\"hann\""
            ], 
            "maxPeaks": [
                "the number of peaks to be considered at each spectrum", 
                "\"(0,inf]50"
            ], 
            "minBpm": [
                "the minimum bpm to consider", 
                "\"[0,inf)30."
            ]
        }, 
        "source": "algorithms/rhythm/bpmhistogram.cpp", 
        "outputs": {
            "_ticks": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_frameBpms": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_tempogram": {
                "type": "TNT::Array2D<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_sinusoid": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_bpm": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_ticksMagnitude": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_bpmCandidates": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_bpmMagnitudes": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/rhythm/bpmhistogram.h", 
        "has_streaming": true
    }, 
    "Clipper": {
        "inputs": {
            "_input": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "max": [
                "the maximum value above which the signal will be clipped", 
                "\"(-inf,inf)1.0"
            ], 
            "min": [
                "the minimum value below which the signal will be clipped", 
                "\"(-inf,inf)-1.0"
            ]
        }, 
        "source": "algorithms/standard/clipper.cpp", 
        "outputs": {
            "_output": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the output signal with the added noise"
            }
        }, 
        "header": "algorithms/standard/clipper.h", 
        "has_streaming": true
    }, 
    "BinaryOperator": {
        "inputs": {
            "_input1": {
                "type": "std::vector<Real>", 
                "name": "array1", 
                "description": "the first operand input array"
            }, 
            "_input2": {
                "type": "std::vector<Real>", 
                "name": "array2", 
                "description": "the second operand input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "type": [
                "the type of the binary operator to apply to the input arrays", 
                "\"{add,subtract,multiply,divide}\"add\""
            ]
        }, 
        "source": "algorithms/standard/binaryoperator.cpp", 
        "outputs": {
            "_output": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the array containing the result of binary operation"
            }
        }, 
        "header": "algorithms/standard/binaryoperator.h", 
        "has_streaming": true
    }, 
    "LoudnessVickers": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the audio sampling rate of the input signal which is used to create the weight vector [Hz] (currently, this algorithm only works on signals with a sampling rate of 44100Hz)", 
                "\"[44100,44100]44100."
            ]
        }, 
        "source": "algorithms/temporal/loudnessvickers.cpp", 
        "outputs": {
            "_loudness": {
                "type": "Real", 
                "name": "loudness", 
                "description": "the Vickers loudness [dB]"
            }
        }, 
        "header": "algorithms/temporal/loudnessvickers.h", 
        "has_streaming": true
    }, 
    "LowPass": {
        "inputs": {
            "_x": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input audio signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "cutoffFrequency": [
                "the cutoff frequency for the filter [Hz]", 
                "\"(0,inf)1500."
            ]
        }, 
        "source": "algorithms/filters/lowpass.cpp", 
        "outputs": {
            "_y": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the filtered signal"
            }
        }, 
        "header": "algorithms/filters/lowpass.h", 
        "has_streaming": true
    }, 
    "PowerMean": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array (must contain only positive real numbers)"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "power": [
                "the power to which to elevate each element before taking the mean", 
                "\"(-inf,inf)1.0"
            ]
        }, 
        "source": "algorithms/stats/powermean.cpp", 
        "outputs": {
            "_powerMean": {
                "type": "Real", 
                "name": "powerMean", 
                "description": "the power mean of the input array"
            }
        }, 
        "header": "algorithms/stats/powermean.h", 
        "has_streaming": true
    }, 
    "PitchContours": {
        "inputs": {
            "_peakBins": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "peakBins", 
                "description": "frame-wise array of cent bins corresponding to pitch salience function peaks"
            }, 
            "_peakSaliences": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "peakSaliences", 
                "description": "frame-wise array of values of salience function peaks"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "binResolution": [
                "salience function bin resolution [cents]", 
                "\"(0,inf)10.0"
            ], 
            "peakFrameThreshold": [
                "per-frame salience threshold factor (fraction of the highest peak salience in a frame)", 
                "\"[0,1]0.9"
            ], 
            "hopSize": [
                "the hop size with which the pitch salience function was computed", 
                "\"(0,inf)128"
            ], 
            "minDuration": [
                "the minimum allowed contour duration [ms]", 
                "\"(0,inf)100."
            ], 
            "peakDistributionThreshold": [
                "allowed deviation below the peak salience mean over all frames (fraction of the standard deviation)", 
                "\"[0,2]0.9"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "pitchContinuity": [
                "pitch continuity cue (maximum allowed pitch change durig 1 ms time period) [cents]", 
                "\"[0,inf)27.5625"
            ], 
            "timeContinuity": [
                "time continuity cue (the maximum allowed gap duration for a pitch contour) [ms]", 
                "\"(0,inf)100."
            ]
        }, 
        "source": "algorithms/tonal/pitchcontours.cpp", 
        "outputs": {
            "_contoursStartTimes": {
                "type": "std::vector<Real>", 
                "name": "contoursStartTimes", 
                "description": "array of start times of each contour [s]"
            }, 
            "_contoursBins": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "contoursBins", 
                "description": "array of frame-wise vectors of cent bin values representing each contour"
            }, 
            "_duration": {
                "type": "Real", 
                "name": "duration", 
                "description": "time duration of the input signal [s]"
            }, 
            "_contoursSaliences": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "contoursSaliences", 
                "description": "array of frame-wise vectors of pitch saliences representing each contour"
            }
        }, 
        "header": "algorithms/tonal/pitchcontours.h", 
        "has_streaming": true
    }, 
    "BeatsLoudness": {
        "inputs": {
            "_signal": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "beatDuration": [
                "the duration of the window in which the", 
                " "
            ], 
            "beatWindowDuration": [
                "the duration of the window in", 
                " "
            ], 
            "sampleRate": [
                "the audio sampling rate [Hz]", 
                "\""
            ], 
            "frequencyBands": [
                "the list of bands to compute energy ratios [Hz", 
                "\"arrayToVector<Real>(defaultBands)"
            ], 
            "beats": [
                "the list of beat positions (each position is in", 
                " "
            ]
        }, 
        "source": "algorithms/rhythm/beatsloudness.cpp", 
        "outputs": {
            "_loudnessBandRatio": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_loudness": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/rhythm/beatsloudness.h", 
        "has_streaming": true
    }, 
    "MetadataReader": {
        "inputs": {}, 
        "has_standard": true, 
        "parameters": {
            "failOnError": [
                "if true, the algorithm throws an exception when encountering an error (e.g. trying to open an unsupported file format), otherwise the algorithm leaves all fields blank", 
                "\"{true,false}false"
            ], 
            "filterMetadataTags": [
                "the list of tags to whitelist (original taglib names)", 
                "\"std::vector<std::string>()"
            ], 
            "filterMetadata": [
                "if true, only add tags from filterMetadataTags to the pool", 
                "\"false"
            ], 
            "tagPoolName": [
                "common prefix for tag descriptor names to use in tagPool", 
                "\"\"metadata.tags\""
            ], 
            "filename": [
                "the name of the file from which to read the tags", 
                "\"Parameter::STRING"
            ]
        }, 
        "source": "algorithms/io/metadatareader.cpp", 
        "outputs": {
            "_comment": {
                "type": "std::string", 
                "name": "comment", 
                "description": "the comment field stored in the tags"
            }, 
            "_channels": {
                "type": "int", 
                "name": "channels", 
                "description": "the number of channels"
            }, 
            "_track": {
                "type": "std::string", 
                "name": "tracknumber", 
                "description": "the track number"
            }, 
            "_tagPool": {
                "type": "Pool", 
                "name": "tagPool", 
                "description": "the pool with all tags that were found"
            }, 
            "_duration": {
                "type": "int", 
                "name": "in seconds", 
                "description": "in seconds"
            }, 
            "_title": {
                "type": "std::string", 
                "name": "title", 
                "description": "the title of the track"
            }, 
            "_artist": {
                "type": "std::string", 
                "name": "artist", 
                "description": "the artist of the track"
            }, 
            "_bitrate": {
                "type": "int", 
                "name": "bitrate", 
                "description": "the bitrate of the track [kb/s]"
            }, 
            "_date": {
                "type": "std::string", 
                "name": "date", 
                "description": "the date of publication"
            }, 
            "_sampleRate": {
                "type": "int", 
                "name": "sampleRate", 
                "description": "the sample rate [Hz]"
            }, 
            "_album": {
                "type": "std::string", 
                "name": "album", 
                "description": "the album on which this track appears"
            }, 
            "_genre": {
                "type": "std::string", 
                "name": "genre", 
                "description": "the genre as stored in the tags"
            }
        }, 
        "header": "algorithms/io/metadatareader.h", 
        "has_streaming": true
    }, 
    "MultiPitchMelodia": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "guessUnvoiced": [
                "estimate pitch for non-voiced segments by using non-salient contours when no salient ones are present in a frame", 
                "\"{false,true}false"
            ], 
            "referenceFrequency": [
                "the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin", 
                "\"(0,inf)55.0"
            ], 
            "filterIterations": [
                "number of iterations for the octave errors / pitch outlier filtering process", 
                "\"[1,inf)3"
            ], 
            "minDuration": [
                "the minimum allowed contour duration [ms]", 
                "\"(0,inf)100"
            ], 
            "binResolution": [
                "salience function bin resolution [cents]", 
                "\"(0,inf)10.0"
            ], 
            "frameSize": [
                "the frame size for computing pitch saliecnce", 
                "\"(0,inf)2048"
            ], 
            "magnitudeThreshold": [
                "spectral peak magnitude threshold (maximum allowed difference from the highest peak in dBs)", 
                "\"[0,inf) 40"
            ], 
            "peakFrameThreshold": [
                "per-frame salience threshold factor (fraction of the highest peak salience in a frame)", 
                "\"[0,1]0.9"
            ], 
            "maxFrequency": [
                "the minimum allowed frequency for salience function peaks (ignore contours with peaks above) [Hz]", 
                "\"[0,inf)20000.0"
            ], 
            "minFrequency": [
                "the minimum allowed frequency for salience function peaks (ignore contours with peaks below) [Hz]", 
                "\"[0,inf)40.0"
            ], 
            "hopSize": [
                "the hop size with which the pitch salience function was computed", 
                "\"(0,inf)128"
            ], 
            "numberHarmonics": [
                "number of considered harmonics", 
                "\"[1,inf)20"
            ], 
            "harmonicWeight": [
                "harmonic weighting parameter (weight decay ratio between two consequent harmonics, =1 for no decay)", 
                "\"(0,1)0.8"
            ], 
            "peakDistributionThreshold": [
                "allowed deviation below the peak salience mean over all frames (fraction of the standard deviation)", 
                "\"[0,2]0.9"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "pitchContinuity": [
                "pitch continuity cue (maximum allowed pitch change during 1 ms time period) [cents]", 
                "\"[0,inf)27.5625"
            ], 
            "magnitudeCompression": [
                "magnitude compression parameter for the salience function (=0 for maximum compression, =1 for no compression)", 
                "\"(0,1]1.0"
            ], 
            "timeContinuity": [
                "time continuity cue (the maximum allowed gap duration for a pitch contour) [ms]", 
                "\"(0,inf)100"
            ]
        }, 
        "source": "algorithms/tonal/multipitchmelodia.cpp", 
        "outputs": {
            "_pitch": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "pitch", 
                "description": "the estimated pitch values [Hz]"
            }
        }, 
        "header": "algorithms/tonal/multipitchmelodia.h", 
        "has_streaming": true
    }, 
    "BeatTrackerMultiFeature": {
        "inputs": {
            "_signal": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "maxTempo": [
                "the fastest tempo to detect [bpm]", 
                "\"[60,250]208"
            ], 
            "minTempo": [
                "the slowest tempo to detect [bpm]", 
                "\"[40,180]40"
            ]
        }, 
        "source": "algorithms/rhythm/beattrackermultifeature.cpp", 
        "outputs": {
            "_confidence": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_ticks": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/rhythm/beattrackermultifeature.h", 
        "has_streaming": true
    }, 
    "EasyLoader": {
        "inputs": {}, 
        "has_standard": true, 
        "parameters": {
            "filename": [
                "the name of the file from which to read", 
                "\"Parameter::STRING"
            ], 
            "downmix": [
                "the mixing type for stereo files", 
                "\"{left,right,mix}\"mix\""
            ], 
            "replayGain": [
                "the value of the replayGain that should be used to normalize the signal [dB]", 
                "\"(-inf,inf)-6.0"
            ], 
            "startTime": [
                "the start time of the slice to be extracted [s]", 
                "\"[0,inf)0.0"
            ], 
            "sampleRate": [
                "the output sampling rate [Hz]", 
                "\"(0,inf)44100."
            ], 
            "endTime": [
                "the end time of the slice to be extracted [s]", 
                "\"[0,inf)1e6"
            ]
        }, 
        "source": "algorithms/io/easyloader.cpp", 
        "outputs": {
            "_audio": {
                "type": "AudioSample", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/io/easyloader.h", 
        "has_streaming": true
    }, 
    "SpectralComplexity": {
        "inputs": {
            "_spectrum": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the input spectrum"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "magnitudeThreshold": [
                "the minimum spectral-peak magnitude that contributes to spectral complexity", 
                "\"[0,inf)0.005"
            ], 
            "sampleRate": [
                "the audio sampling rate [Hz]", 
                "\"(0,inf)44100."
            ]
        }, 
        "source": "algorithms/spectral/spectralcomplexity.cpp", 
        "outputs": {
            "_spectralComplexity": {
                "type": "Real", 
                "name": "spectralComplexity", 
                "description": "the spectral complexity of the input spectrum"
            }
        }, 
        "header": "algorithms/spectral/spectralcomplexity.h", 
        "has_streaming": true
    }, 
    "Scale": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input audio signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "clipping": [
                "boolean flag whether to apply clipping or not", 
                "\"{true,false}true"
            ], 
            "maxAbsValue": [
                "the maximum value above which to apply clipping", 
                "\"[0,inf)1.0"
            ], 
            "factor": [
                "the multiplication factor by which the audio will be scaled", 
                "\"[0,inf)10.0"
            ]
        }, 
        "source": "algorithms/standard/scale.cpp", 
        "outputs": {
            "_scaled": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the output audio signal"
            }
        }, 
        "header": "algorithms/standard/scale.h", 
        "has_streaming": true
    }, 
    "Danceability": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "minTau": [
                "minimum segment length to consider [ms]", 
                "\"(0,inf)310."
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "tauMultiplier": [
                "multiplier to increment from min to max tau", 
                "\"[1,inf)1.1"
            ], 
            "maxTau": [
                "maximum segment length to consider [ms]", 
                "\"(0,inf)8800."
            ]
        }, 
        "source": "algorithms/highlevel/danceability.cpp", 
        "outputs": {
            "_danceability": {
                "type": "Real", 
                "name": "the more danceable.", 
                "description": "the more danceable."
            }
        }, 
        "header": "algorithms/highlevel/danceability.h", 
        "has_streaming": true
    }, 
    "TuningFrequency": {
        "inputs": {
            "_frequencies": {
                "type": "std::vector<Real>", 
                "name": "frequencies", 
                "description": "the frequencies of the spectral peaks [Hz]"
            }, 
            "_magnitudes": {
                "type": "std::vector<Real>", 
                "name": "magnitudes", 
                "description": "the magnitudes of the spectral peaks"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "resolution": [
                "resolution in cents (logarithmic scale, 100 cents = 1 semitone) for tuning frequency determination", 
                "\"(0,inf)1.0"
            ]
        }, 
        "source": "algorithms/tonal/tuningfrequency.cpp", 
        "outputs": {
            "_tuningCents": {
                "type": "Real", 
                "name": "tuningCents", 
                "description": "tuningCentsDescription.str()"
            }, 
            "_tuningFrequency": {
                "type": "Real", 
                "name": "tuningFrequency", 
                "description": "the tuning frequency [Hz]"
            }
        }, 
        "header": "algorithms/tonal/tuningfrequency.h", 
        "has_streaming": true
    }, 
    "HFC": {
        "inputs": {
            "_spectrum": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the input audio spectrum"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf]44100.0"
            ], 
            "type": [
                "the type of HFC coefficient to be computed", 
                "\"{Masri,Jensen,Brossier}\"Masri\""
            ]
        }, 
        "source": "algorithms/spectral/hfc.cpp", 
        "outputs": {
            "_hfc": {
                "type": "Real", 
                "name": "hfc", 
                "description": "the high-frequency coefficient"
            }
        }, 
        "header": "algorithms/spectral/hfc.h", 
        "has_streaming": true
    }, 
    "Crest": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "and must be non-empty)", 
                "description": "and must be non-empty)"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/stats/crest.cpp", 
        "outputs": {
            "_crest": {
                "type": "Real", 
                "name": "crest", 
                "description": "the crest of the input array"
            }
        }, 
        "header": "algorithms/stats/crest.h", 
        "has_streaming": true
    }, 
    "RMS": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/stats/rms.cpp", 
        "outputs": {
            "_rms": {
                "type": "Real", 
                "name": "rms", 
                "description": "the root mean square of the input array"
            }
        }, 
        "header": "algorithms/stats/rms.h", 
        "has_streaming": true
    }, 
    "LoudnessEBUR128": {
        "inputs": {
            "_signal": {
                "type": "StereoSample", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": false, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "hopSize": [
                "the hop size with which the loudness is computed [s]", 
                "\"(0,0.1]0.1"
            ]
        }, 
        "source": "algorithms/temporal/loudnessebur128.cpp", 
        "outputs": {
            "_momentaryLoudness": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_loudnessRange": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_integratedLoudness": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_shortTermLoudnessMax": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_shortTermLoudness": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_momentaryLoudnessMax": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/temporal/loudnessebur128.h", 
        "has_streaming": true
    }, 
    "PitchSalienceFunction": {
        "inputs": {
            "_frequencies": {
                "type": "std::vector<Real>", 
                "name": "frequencies", 
                "description": "the frequencies of the spectral peaks [Hz]"
            }, 
            "_magnitudes": {
                "type": "std::vector<Real>", 
                "name": "magnitudes", 
                "description": "the magnitudes of the spectral peaks"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "referenceFrequency": [
                "the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin", 
                "\"(0,inf)55.0"
            ], 
            "binResolution": [
                "salience function bin resolution [cents]", 
                "\"(0,inf)10.0"
            ], 
            "magnitudeThreshold": [
                "peak magnitude threshold (maximum allowed difference from the highest peak in dBs)", 
                "\"[0,inf) 40.0"
            ], 
            "numberHarmonics": [
                "number of considered harmonics", 
                "\"[1,inf)20"
            ], 
            "harmonicWeight": [
                "harmonic weighting parameter (weight decay ratio between two consequent harmonics, =1 for no decay)", 
                "\"(0,1)0.8"
            ], 
            "magnitudeCompression": [
                "magnitude compression parameter (=0 for maximum compression, =1 for no compression)", 
                "\"(0,1]1.0"
            ]
        }, 
        "source": "algorithms/tonal/pitchsaliencefunction.cpp", 
        "outputs": {
            "_salienceFunction": {
                "type": "std::vector<Real>", 
                "name": "salienceFunction", 
                "description": "array of the quantized pitch salience values"
            }
        }, 
        "header": "algorithms/tonal/pitchsaliencefunction.h", 
        "has_streaming": true
    }, 
    "RhythmExtractor": {
        "inputs": {
            "_signal": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "frameSize": [
                "the number audio samples used to compute a feature", 
                "\"(0,inf)1024"
            ], 
            "maxTempo": [
                "the fastest tempo to detect [bpm]", 
                "\"[60,250]208"
            ], 
            "minTempo": [
                "the slowest tempo to detect [bpm]", 
                "\"[40,180]40"
            ], 
            "useBands": [
                "whether or not to use band energy as periodicity function", 
                "\"{true,false}true"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "tempoHints": [
                "the optional list of initial beat locations, to favor the detection of pre-determined tempo period and beats alignment [s]", 
                "\"std::vector<Real>()"
            ], 
            "hopSize": [
                "the number of audio samples per features", 
                "\"(0,inf)256"
            ], 
            "lastBeatInterval": [
                "the minimum interval between last beat and end of file [s]", 
                "\"[0,inf)0.100"
            ], 
            "frameHop": [
                "the number of feature frames separating two evaluations", 
                "\"(0,inf)1024"
            ], 
            "useOnset": [
                "whether or not to use onsets as periodicity function", 
                "\"{true,false}true"
            ], 
            "tolerance": [
                "the minimum interval between two consecutive beats [s]", 
                "\"[0,inf)0.24"
            ], 
            "numberFrames": [
                "the number of feature frames to buffer on", 
                "\"(0,inf)1024"
            ]
        }, 
        "source": "algorithms/rhythm/rhythmextractor.cpp", 
        "outputs": {
            "_ticks": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_estimates": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_bpm": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_bpmIntervals": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/rhythm/rhythmextractor.h", 
        "has_streaming": true
    }, 
    "BandPass": {
        "inputs": {
            "_x": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input audio signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "cutoffFrequency": [
                "the cutoff frequency for the filter [Hz]", 
                "\"(0,inf)1500."
            ], 
            "bandwidth": [
                "the bandwidth of the filter [Hz]", 
                "\"(0,inf)500."
            ]
        }, 
        "source": "algorithms/filters/bandpass.cpp", 
        "outputs": {
            "_y": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the filtered signal"
            }
        }, 
        "header": "algorithms/filters/bandpass.h", 
        "has_streaming": true
    }, 
    "FrameCutter": {
        "inputs": {
            "_buffer": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the buffer from which to read data"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "lastFrameToEndOfFile": [
                "whether the beginning of the last", 
                " "
            ], 
            "startFromZero": [
                "whether to start the first frame at", 
                " "
            ], 
            "validFrameThresholdRatio": [
                "frames smaller than this", 
                " "
            ], 
            "frameSize": [
                "the output frame size", 
                "\"[1,inf)1024"
            ], 
            "hopSize": [
                "the hop size between frames", 
                "\"[1,inf)512"
            ]
        }, 
        "source": "algorithms/standard/framecutter.cpp", 
        "outputs": {
            "_frame": {
                "type": "std::vector<Real>", 
                "name": "frame", 
                "description": "the frame to write to"
            }
        }, 
        "header": "algorithms/standard/framecutter.h", 
        "has_streaming": true
    }, 
    "FrequencyBands": {
        "inputs": {
            "_spectrumInput": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the input spectrum (must be greater than size one)"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "frequencyBands": [
                "list of frequency ranges in to which the spectrum is divided (these must be in ascending order and connot contain duplicates)", 
                "\"arrayToVector<Real>(freqBands)"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ]
        }, 
        "source": "algorithms/spectral/frequencybands.cpp", 
        "outputs": {
            "_bandsOutput": {
                "type": "std::vector<Real>", 
                "name": "bands", 
                "description": "the energy in each band"
            }
        }, 
        "header": "algorithms/spectral/frequencybands.h", 
        "has_streaming": true
    }, 
    "PitchContourSegmentation": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "input audio signal"
            }, 
            "_pitch": {
                "type": "std::vector<Real>", 
                "name": "pitch", 
                "description": "estimated pitch contour [Hz]"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "pitchDistanceThreshold": [
                "pitch threshold for note segmentation [cents]", 
                "\"(0,inf)60"
            ], 
            "rmsThreshold": [
                "zscore threshold for note segmentation", 
                "\"(0,-inf)-2"
            ], 
            "tuningFreq": [
                "tuning reference frequency  [Hz]", 
                "\"(0,22000)440"
            ], 
            "minDur": [
                "minimum note duration [s]", 
                "\"(0,inf)0.1"
            ], 
            "hopSize": [
                "hop size of the extracted pitch", 
                "\"(0,inf)128"
            ], 
            "sampleRate": [
                "sample rate of the audio signal", 
                "\"(0,inf)44100"
            ]
        }, 
        "source": "algorithms/tonal/pitchcontoursegmentation.cpp", 
        "outputs": {
            "_MIDIpitch": {
                "type": "std::vector<Real>", 
                "name": "MIDIpitch", 
                "description": "quantized MIDI pitch value"
            }, 
            "_duration": {
                "type": "std::vector<Real>", 
                "name": "duration", 
                "description": "note durations [s]"
            }, 
            "_onset": {
                "type": "std::vector<Real>", 
                "name": "onset", 
                "description": "note onset times [s]"
            }
        }, 
        "header": "algorithms/tonal/pitchcontoursegmentation.h", 
        "has_streaming": false
    }, 
    "EnergyBand": {
        "inputs": {
            "_spectrum": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the input frequency spectrum"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "stopCutoffFrequency": [
                "the stop frequency to which to sum the energy [Hz]", 
                "\"(0,inf)100.0"
            ], 
            "sampleRate": [
                "the audio sampling rate [Hz]", 
                "\"(0,inf)44100."
            ], 
            "startCutoffFrequency": [
                "the start frequency from which to sum the energy [Hz]", 
                "\"[0,inf)0.0"
            ]
        }, 
        "source": "algorithms/spectral/energyband.cpp", 
        "outputs": {
            "_energyBand": {
                "type": "Real", 
                "name": "energyBand", 
                "description": "the energy in the frequency band"
            }
        }, 
        "header": "algorithms/spectral/energyband.h", 
        "has_streaming": true
    }, 
    "TempoTapTicks": {
        "inputs": {
            "_phases": {
                "type": "std::vector<Real>", 
                "name": "in frames", 
                "description": "in frames"
            }, 
            "_periods": {
                "type": "std::vector<Real>", 
                "name": "in frames", 
                "description": "in frames"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "frameHop": [
                "number of feature frames separating two evaluations", 
                "\"(0,inf)512"
            ], 
            "sampleRate": [
                "sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "hopSize": [
                "number of audio samples per features", 
                "\"(0,inf)256"
            ]
        }, 
        "source": "algorithms/rhythm/tempotapticks.cpp", 
        "outputs": {
            "_matchingPeriods": {
                "type": "std::vector<Real>", 
                "name": "matchingPeriods", 
                "description": "list of matching periods [s]"
            }, 
            "_ticks": {
                "type": "std::vector<Real>", 
                "name": "ticks", 
                "description": "the list of resulting ticks [s]"
            }
        }, 
        "header": "algorithms/rhythm/tempotapticks.h", 
        "has_streaming": true
    }, 
    "BpmHistogramDescriptors": {
        "inputs": {
            "_bpmIntervals": {
                "type": "std::vector<Real>", 
                "name": "bpmIntervals", 
                "description": "the list of bpm intervals [s]"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/rhythm/bpmhistogramdescriptors.cpp", 
        "outputs": {
            "_secondPeakSpread": {
                "type": "Real", 
                "name": "secondPeakSpread", 
                "description": "spread of the second highest peak"
            }, 
            "_histogram": {
                "type": "std::vector<Real>", 
                "name": "histogram", 
                "description": "bpm histogram [bpm]"
            }, 
            "_firstPeakBPM": {
                "type": "Real", 
                "name": "firstPeakBPM", 
                "description": "value for the highest peak [bpm]"
            }, 
            "_firstPeakWeight": {
                "type": "Real", 
                "name": "firstPeakWeight", 
                "description": "weight of the highest peak"
            }, 
            "_secondPeakBPM": {
                "type": "Real", 
                "name": "secondPeakBPM", 
                "description": "value for the second highest peak [bpm]"
            }, 
            "_firstPeakSpread": {
                "type": "Real", 
                "name": "firstPeakSpread", 
                "description": "spread of the highest peak"
            }, 
            "_secondPeakWeight": {
                "type": "Real", 
                "name": "secondPeakWeight", 
                "description": "weight of the second highest peak"
            }
        }, 
        "header": "algorithms/rhythm/bpmhistogramdescriptors.h", 
        "has_streaming": true
    }, 
    "MovingAverage": {
        "inputs": {
            "_x": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input audio signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "size": [
                "the size of the window [audio samples]", 
                "\"(1,inf)6"
            ]
        }, 
        "source": "algorithms/filters/movingaverage.cpp", 
        "outputs": {
            "_y": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the filtered signal"
            }
        }, 
        "header": "algorithms/filters/movingaverage.h", 
        "has_streaming": true
    }, 
    "Magnitude": {
        "inputs": {
            "_complex": {
                "type": "std::vector<std::complex<Real> >", 
                "name": "complex", 
                "description": "the input vector of complex numbers"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/complex/magnitude.cpp", 
        "outputs": {
            "_magnitude": {
                "type": "std::vector<Real>", 
                "name": "magnitude", 
                "description": "the magnitudes of the input vector"
            }
        }, 
        "header": "algorithms/complex/magnitude.h", 
        "has_streaming": true
    }, 
    "DistributionShape": {
        "inputs": {
            "_centralMoments": {
                "type": "std::vector<Real>", 
                "name": "centralMoments", 
                "description": "the central moments of a distribution"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/stats/distributionshape.cpp", 
        "outputs": {
            "_skewness": {
                "type": "Real", 
                "name": "skewness", 
                "description": "the skewness of the distribution"
            }, 
            "_spread": {
                "type": "Real", 
                "name": "spread", 
                "description": "the spread (variance) of the distribution"
            }, 
            "_kurtosis": {
                "type": "Real", 
                "name": "kurtosis", 
                "description": "the kurtosis of the distribution"
            }
        }, 
        "header": "algorithms/stats/distributionshape.h", 
        "has_streaming": true
    }, 
    "MinToTotal": {
        "inputs": {
            "_envelope": {
                "type": "std::vector<Real>", 
                "name": "envelope", 
                "description": "the envelope of the signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/sfx/mintototal.cpp", 
        "outputs": {
            "_minToTotal": {
                "type": "Real", 
                "name": "minToTotal", 
                "description": "the minimum amplitude position to total length ratio"
            }
        }, 
        "header": "algorithms/sfx/mintototal.h", 
        "has_streaming": true
    }, 
    "Loudness": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/temporal/loudness.cpp", 
        "outputs": {
            "_loudness": {
                "type": "Real", 
                "name": "loudness", 
                "description": "the loudness of the input signal"
            }
        }, 
        "header": "algorithms/temporal/loudness.h", 
        "has_streaming": true
    }, 
    "ERBBands": {
        "inputs": {
            "_spectrumInput": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the audio spectrum"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "inputSize": [
                "the size of the spectrum", 
                "\"(1,inf)1025"
            ], 
            "type": [
                "compute energies or magnitudes", 
                "\"{energy,magnitude}\"energy\""
            ], 
            "numberBands": [
                "the number of output bands", 
                "\"(1,inf)40"
            ], 
            "lowFrequencyBound": [
                "a lower-bound limit for the frequencies to be included in the bands", 
                "\"[0,inf)50.0"
            ], 
            "width": [
                "filter width with respect to ERB", 
                "\"(0,inf)1.0"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "highFrequencyBound": [
                "an upper-bound limit for the frequencies to be included in the bands", 
                "\"[0,inf)22050.0"
            ]
        }, 
        "source": "algorithms/spectral/erbbands.cpp", 
        "outputs": {
            "_bandsOutput": {
                "type": "std::vector<Real>", 
                "name": "bands", 
                "description": "the energies/magnitudes of each band"
            }
        }, 
        "header": "algorithms/spectral/erbbands.h", 
        "has_streaming": true
    }, 
    "CentralMoments": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "range": [
                "the range of the input array, used for normalizing the results", 
                "\"(0,inf)1.0"
            ]
        }, 
        "source": "algorithms/stats/centralmoments.cpp", 
        "outputs": {
            "_centralMoments": {
                "type": "std::vector<Real>", 
                "name": "centralMoments", 
                "description": "the central moments of the input array"
            }
        }, 
        "header": "algorithms/stats/centralmoments.h", 
        "has_streaming": true
    }, 
    "LevelExtractor": {
        "inputs": {
            "_signal": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "frameSize": [
                "frame size to compute loudness", 
                "\"(0,inf)88200"
            ], 
            "hopSize": [
                "hop size to compute loudness", 
                "\"(0,inf)44100"
            ]
        }, 
        "source": "algorithms/extractor/levelextractor.cpp", 
        "outputs": {
            "_loudnessValue": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/extractor/levelextractor.h", 
        "has_streaming": true
    }, 
    "YamlInput": {
        "inputs": {}, 
        "has_standard": true, 
        "parameters": {
            "format": [
                "whether to the input file is in JSON or YAML format", 
                "\"{json,yaml}\"yaml\""
            ], 
            "filename": [
                "Input filename", 
                "\"Parameter::STRING"
            ]
        }, 
        "source": "algorithms/io/yamlinput.cpp", 
        "outputs": {
            "_pool": {
                "type": "Pool", 
                "name": "pool", 
                "description": "Pool of deserialized values"
            }
        }, 
        "header": "algorithms/io/yamlinput.h", 
        "has_streaming": false
    }, 
    "FFTW": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "frame", 
                "description": "the input audio frame"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "size": [
                "the expected size of the input frame. This is purely optional and only targeted at optimizing the creation time of the FFT object", 
                "\"[1,inf)1024"
            ]
        }, 
        "source": "algorithms/standard/fftw.cpp", 
        "outputs": {
            "_fft": {
                "type": "std::vector<std::complex<Real> >", 
                "name": "fft", 
                "description": "the FFT of the input frame"
            }
        }, 
        "header": "algorithms/standard/fftw.h", 
        "has_streaming": true
    }, 
    "Decrease": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "range": [
                "the range of the input array, used for normalizing the results", 
                "\"(-inf,inf)1.0"
            ]
        }, 
        "source": "algorithms/stats/decrease.cpp", 
        "outputs": {
            "_decrease": {
                "type": "Real", 
                "name": "decrease", 
                "description": "the decrease of the input array"
            }
        }, 
        "header": "algorithms/stats/decrease.h", 
        "has_streaming": true
    }, 
    "PeakDetection": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "orderBy": [
                "the ordering type of the output peaks (ascending by position or descending by value)", 
                "\"{position,amplitude}\"position\""
            ], 
            "maxPosition": [
                "the maximum value of the range to evaluate", 
                "\"(0,inf)1.0"
            ], 
            "interpolate": [
                "boolean flag to enable interpolation", 
                "\"{true,false}true"
            ], 
            "range": [
                "the input range", 
                "\"(0,inf)1.0"
            ], 
            "maxPeaks": [
                "the maximum number of returned peaks", 
                "\"[1,inf)100"
            ], 
            "threshold": [
                "peaks below this given threshold are not output", 
                "\"(-inf,inf)-1e6"
            ], 
            "minPosition": [
                "the minimum value of the range to evaluate", 
                "\"[0,inf)0.0"
            ]
        }, 
        "source": "algorithms/standard/peakdetection.cpp", 
        "outputs": {
            "_positions": {
                "type": "std::vector<Real>", 
                "name": "positions", 
                "description": "the positions of the peaks"
            }, 
            "_values": {
                "type": "std::vector<Real>", 
                "name": "amplitudes", 
                "description": "the amplitudes of the peaks"
            }
        }, 
        "header": "algorithms/standard/peakdetection.h", 
        "has_streaming": true
    }, 
    "OnsetRate": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/highlevel/onsetrate.cpp", 
        "outputs": {
            "_onsetTimes": {
                "type": "std::vector<Real>", 
                "name": "onsets", 
                "description": "the positions of detected onsets [s]"
            }, 
            "_onsetRate": {
                "type": "Real", 
                "name": "onsetRate", 
                "description": "the number of onsets per second"
            }
        }, 
        "header": "algorithms/highlevel/onsetrate.h", 
        "has_streaming": true
    }, 
    "Dissonance": {
        "inputs": {
            "_frequencies": {
                "type": "std::vector<Real>", 
                "name": "frequencies", 
                "description": "the frequencies of the spectral peaks (must be sorted by frequency)"
            }, 
            "_magnitudes": {
                "type": "std::vector<Real>", 
                "name": "magnitudes", 
                "description": "the magnitudes of the spectral peaks (must be sorted by frequency"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/tonal/dissonance.cpp", 
        "outputs": {
            "_dissonance": {
                "type": "Real", 
                "name": "and 1 meaning completely dissonant)", 
                "description": "and 1 meaning completely dissonant)"
            }
        }, 
        "header": "algorithms/tonal/dissonance.h", 
        "has_streaming": true
    }, 
    "BPF": {
        "inputs": {
            "_xInput": {
                "type": "Real", 
                "name": "x", 
                "description": "the input coordinate (x-axis)"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "xPoints": [
                "the x-coordinates of the points forming the break-point function (the points must be arranged in ascending order and cannot contain duplicates)", 
                "\"defaultPoints"
            ], 
            "yPoints": [
                "the y-coordinates of the points forming the break-point function", 
                "\"defaultPoints"
            ]
        }, 
        "source": "algorithms/standard/bpf.cpp", 
        "outputs": {
            "_yOutput": {
                "type": "Real", 
                "name": "y", 
                "description": "the output coordinate (y-axis)"
            }
        }, 
        "header": "algorithms/standard/bpf.h", 
        "has_streaming": true
    }, 
    "HighResolutionFeatures": {
        "inputs": {
            "_hpcp": {
                "type": "std::vector<Real>", 
                "name": "preferably of size >= 120", 
                "description": "preferably of size >= 120"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "maxPeaks": [
                "maximum number of HPCP peaks to consider when calculating outputs", 
                "\"[1,inf)24"
            ]
        }, 
        "source": "algorithms/tonal/highresolutionfeatures.cpp", 
        "outputs": {
            "_nt2tEnergyRatio": {
                "type": "Real", 
                "name": "nonTemperedEnergyRatio", 
                "description": ""
            }, 
            "_equalTemperedDeviation": {
                "type": "Real", 
                "name": "equalTemperedDeviation", 
                "description": ""
            }, 
            "_nt2tPeaksEnergyRatio": {
                "type": "Real", 
                "name": "nonTemperedPeaksEnergyRatio", 
                "description": ""
            }
        }, 
        "header": "algorithms/tonal/highresolutionfeatures.h", 
        "has_streaming": true
    }, 
    "Multiplexer": {
        "inputs": {
            "_realInputs": {
                "type": "Real>*", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_vectorRealInputs": {
                "type": "std::vector<Real> >*", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "numberRealInputs": [
                "the number of inputs of type Real to multiplex", 
                "\"[0,inf)0"
            ], 
            "numberVectorRealInputs": [
                "the number of inputs of type vector<Real> to multiplex", 
                "\"[0,inf)0"
            ]
        }, 
        "source": "algorithms/standard/multiplexer.cpp", 
        "outputs": {
            "_output": {
                "type": "std::vector<Real>", 
                "name": "the frame containing the input values and/or input frames", 
                "description": "the frame containing the input values and/or input frames"
            }
        }, 
        "header": "algorithms/standard/multiplexer.h", 
        "has_streaming": true
    }, 
    "BinaryOperatorStream": {
        "inputs": {
            "_input1": {
                "type": "std::vector<Real>", 
                "name": "array1", 
                "description": "the first operand input array"
            }, 
            "_input2": {
                "type": "std::vector<Real>", 
                "name": "array2", 
                "description": "the second operand input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "type": [
                "the type of the binary operator to apply to the input arrays", 
                "\"{add,subtract,multiply,divide}\"add\""
            ]
        }, 
        "source": "algorithms/standard/binaryoperatorstream.cpp", 
        "outputs": {
            "_output": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the array containing the result of binary operation"
            }
        }, 
        "header": "algorithms/standard/binaryoperatorstream.h", 
        "has_streaming": true
    }, 
    "AudioLoader": {
        "inputs": {}, 
        "has_standard": true, 
        "parameters": {
            "computeMD5": [
                "compute the MD5 checksum", 
                "\"{true,false}false"
            ], 
            "filename": [
                "the name of the file from which to read", 
                "\"Parameter::STRING"
            ]
        }, 
        "source": "algorithms/io/audioloader.cpp", 
        "outputs": {
            "_channels": {
                "type": "int", 
                "name": "the number of channels", 
                "description": "the number of channels"
            }, 
            "_md5": {
                "type": "std::string", 
                "name": "the MD5 checksum of raw undecoded audio payload", 
                "description": "the MD5 checksum of raw undecoded audio payload"
            }, 
            "_bit_rate": {
                "type": "int", 
                "name": "the bit rate of the input audio, as reported by the decoder codec", 
                "description": "the bit rate of the input audio, as reported by the decoder codec"
            }, 
            "_codec": {
                "type": "std::string", 
                "name": "the codec that is used to decode the input audio", 
                "description": "the codec that is used to decode the input audio"
            }, 
            "_sampleRate": {
                "type": "Real", 
                "name": "the sampling rate of the audio signal [Hz]", 
                "description": "the sampling rate of the audio signal [Hz]"
            }, 
            "_audio": {
                "type": "StereoSample", 
                "name": "the input audio signal", 
                "description": "the input audio signal"
            }
        }, 
        "header": "algorithms/io/audioloader.h", 
        "has_streaming": true
    }, 
    "ChordsDetectionBeats": {
        "inputs": {
            "_pcp": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "pcp", 
                "description": "the pitch class profile from which to detect the chord"
            }, 
            "_ticks": {
                "type": "std::vector<Real>", 
                "name": "ticks", 
                "description": "the list of beat positions (in seconds)"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "hopSize": [
                "the hop size with which the input PCPs were computed", 
                "\"(0,inf)2048"
            ]
        }, 
        "source": "algorithms/tonal/chordsdetectionbeats.cpp", 
        "outputs": {
            "_chords": {
                "type": "std::vector<std::string>", 
                "name": "from A to G", 
                "description": "from A to G"
            }, 
            "_strength": {
                "type": "std::vector<Real>", 
                "name": "strength", 
                "description": "the strength of the chords"
            }
        }, 
        "header": "algorithms/tonal/chordsdetectionbeats.h", 
        "has_streaming": false
    }, 
    "PitchYinFFT": {
        "inputs": {
            "_spectrum": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the input spectrum (preferably created with a hann window)"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "maxFrequency": [
                "the maximum allowed frequency [Hz]", 
                "\"(0,inf)22050.0"
            ], 
            "sampleRate": [
                "sampling rate of the input spectrum [Hz]", 
                "\"(0,inf)44100."
            ], 
            "minFrequency": [
                "the minimum allowed frequency [Hz]", 
                "\"(0,inf)20.0"
            ], 
            "frameSize": [
                "number of samples in the input spectrum", 
                "\"[2,inf)2048"
            ], 
            "interpolate": [
                "boolean flag to enable interpolation", 
                "\"{true,false}true"
            ]
        }, 
        "source": "algorithms/tonal/pitchyinfft.cpp", 
        "outputs": {
            "_pitch": {
                "type": "Real", 
                "name": "pitch", 
                "description": "detected pitch [Hz]"
            }, 
            "_pitchConfidence": {
                "type": "Real", 
                "name": "1]", 
                "description": "1]"
            }
        }, 
        "header": "algorithms/tonal/pitchyinfft.h", 
        "has_streaming": true
    }, 
    "CartesianToPolar": {
        "inputs": {
            "_complex": {
                "type": "std::vector<std::complex<Real> >", 
                "name": "complex", 
                "description": "the complex input vector"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/complex/cartesiantopolar.cpp", 
        "outputs": {
            "_magnitude": {
                "type": "std::vector<Real>", 
                "name": "magnitude", 
                "description": "the magnitude vector"
            }, 
            "_phase": {
                "type": "std::vector<Real>", 
                "name": "phase", 
                "description": "the phase vector"
            }
        }, 
        "header": "algorithms/complex/cartesiantopolar.h", 
        "has_streaming": true
    }, 
    "ZeroCrossingRate": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "threshold": [
                "the threshold which will be taken as the zero axis in both positive and negative sign", 
                "\"[0,inf]0.0"
            ]
        }, 
        "source": "algorithms/temporal/zerocrossingrate.cpp", 
        "outputs": {
            "_zeroCrossingRate": {
                "type": "Real", 
                "name": "zeroCrossingRate", 
                "description": "the zero-crossing rate"
            }
        }, 
        "header": "algorithms/temporal/zerocrossingrate.h", 
        "has_streaming": true
    }, 
    "Meter": {
        "inputs": {
            "_beatogram": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "beatogram", 
                "description": "filtered matrix loudness"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/experimental/meter.cpp", 
        "outputs": {
            "_meter": {
                "type": "Real", 
                "name": "meter", 
                "description": "the time signature"
            }
        }, 
        "header": "algorithms/experimental/meter.h", 
        "has_streaming": true
    }, 
    "Derivative": {
        "inputs": {
            "_input": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/standard/derivative.cpp", 
        "outputs": {
            "_output": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the derivative of the input signal"
            }
        }, 
        "header": "algorithms/standard/derivative.h", 
        "has_streaming": true
    }, 
    "LoudnessEBUR128Filter": {
        "inputs": {
            "_signal": {
                "type": "StereoSample", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": false, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ]
        }, 
        "source": "algorithms/temporal/loudnessebur128filter.cpp", 
        "outputs": {
            "_signalFiltered": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/temporal/loudnessebur128filter.h", 
        "has_streaming": true
    }, 
    "RollOff": {
        "inputs": {
            "_spectrum": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the input audio spectrum (must have more than one elements)"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "cutoff": [
                "the ratio of total energy to attain before yielding the roll-off frequency", 
                "\"(0,1)0.85"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal (used to normalize rollOff) [Hz]", 
                "\"(0,inf)44100."
            ]
        }, 
        "source": "algorithms/spectral/rolloff.cpp", 
        "outputs": {
            "_rolloff": {
                "type": "Real", 
                "name": "rollOff", 
                "description": "the roll-off frequency [Hz]"
            }
        }, 
        "header": "algorithms/spectral/rolloff.h", 
        "has_streaming": true
    }, 
    "PitchContoursMelody": {
        "inputs": {
            "_contoursStartTimes": {
                "type": "std::vector<Real>", 
                "name": "contoursStartTimes", 
                "description": "array of the start times of each contour [s]"
            }, 
            "_contoursBins": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "contoursBins", 
                "description": "array of frame-wise vectors of cent bin values representing each contour"
            }, 
            "_duration": {
                "type": "Real", 
                "name": "duration", 
                "description": "time duration of the input signal [s]"
            }, 
            "_contoursSaliences": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "contoursSaliences", 
                "description": "array of frame-wise vectors of pitch saliences representing each contour"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "voicingTolerance": [
                "allowed deviation below the average contour mean salience of all contours (fraction of the standard deviation)", 
                "\"[-1.0,1.4]0.2"
            ], 
            "referenceFrequency": [
                "the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin", 
                "\"(0,inf)55.0"
            ], 
            "filterIterations": [
                "number of interations for the octave errors / pitch outlier filtering process", 
                "\"[1,inf)3"
            ], 
            "binResolution": [
                "salience function bin resolution [cents]", 
                "\"(0,inf)10.0"
            ], 
            "guessUnvoiced": [
                "Estimate pitch for non-voiced segments by using non-salient contours when no salient ones are present in a frame", 
                "\"{false,true}false"
            ], 
            "voiceVibrato": [
                "detect voice vibrato", 
                "\"{true,false}false"
            ], 
            "maxFrequency": [
                "the minimum allowed frequency for salience function peaks (ignore contours with peaks above) [Hz]", 
                "\"[0,inf)20000.0"
            ], 
            "minFrequency": [
                "the minimum allowed frequency for salience function peaks (ignore contours with peaks below) [Hz]", 
                "\"[0,inf)80.0"
            ], 
            "hopSize": [
                "the hop size with which the pitch salience function was computed", 
                "\"(0,inf)128"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal (Hz)", 
                "\"(0,inf)44100."
            ]
        }, 
        "source": "algorithms/tonal/pitchcontoursmelody.cpp", 
        "outputs": {
            "_pitch": {
                "type": "std::vector<Real>", 
                "name": "melody) [Hz]", 
                "description": "melody) [Hz]"
            }, 
            "_pitchConfidence": {
                "type": "std::vector<Real>", 
                "name": "pitchConfidence", 
                "description": "confidence with which the pitch was detected"
            }
        }, 
        "header": "algorithms/tonal/pitchcontoursmelody.h", 
        "has_streaming": true
    }, 
    "AfterMaxToBeforeMaxEnergyRatio": {
        "inputs": {
            "_pitch": {
                "type": "std::vector<Real>", 
                "name": "pitch", 
                "description": "the array of pitch values [Hz]"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/sfx/aftermaxtobeforemaxenergyratio.cpp", 
        "outputs": {
            "_afterMaxToBeforeMaxEnergyRatio": {
                "type": "Real", 
                "name": "afterMaxToBeforeMaxEnergyRatio", 
                "description": ""
            }
        }, 
        "header": "algorithms/sfx/aftermaxtobeforemaxenergyratio.h", 
        "has_streaming": true
    }, 
    "TonalExtractor": {
        "inputs": {
            "_signal": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "tuningFrequency": [
                "the tuning frequency of the input signal", 
                "\"(0,inf)440.0"
            ], 
            "frameSize": [
                "the framesize for computing tonal features", 
                "\"(0,inf)4096"
            ], 
            "hopSize": [
                "the hopsize for computing tonal features", 
                "\"(0,inf)2048"
            ]
        }, 
        "source": "algorithms/extractor/tonalextractor.cpp", 
        "outputs": {
            "_keyStrength": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_keyKey": {
                "type": "std::string", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_chordsStrength": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_chordsScale": {
                "type": "std::string", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_chordsProgression": {
                "type": "std::string", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_chordsNumberRate": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_chordsHistogram": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_chordsKey": {
                "type": "std::string", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_keyScale": {
                "type": "std::string", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_hpcpsTuning": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_hpcps": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_chordsChangesRate": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/extractor/tonalextractor.h", 
        "has_streaming": true
    }, 
    "IIR": {
        "inputs": {
            "_x": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "denominator": [
                "the list of coefficients of the denominator. Often referred to as the A coefficient vector.", 
                "\"defaultParam"
            ], 
            "numerator": [
                "the list of coefficients of the numerator. Often referred to as the B coefficient vector.", 
                "\"defaultParam"
            ]
        }, 
        "source": "algorithms/filters/iir.cpp", 
        "outputs": {
            "_y": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the filtered signal"
            }
        }, 
        "header": "algorithms/filters/iir.h", 
        "has_streaming": true
    }, 
    "Resample": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "inputSampleRate": [
                "the sampling rate of the input signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "quality": [
                "the quality of the conversion, 0 for best quality", 
                "\"[0,4]1"
            ], 
            "outputSampleRate": [
                "the sampling rate of the output signal [Hz]", 
                "\"(0,inf)44100."
            ]
        }, 
        "source": "algorithms/standard/resample.cpp", 
        "outputs": {
            "_resampled": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the resampled signal"
            }
        }, 
        "header": "algorithms/standard/resample.h", 
        "has_streaming": true
    }, 
    "SuperFluxPeaks": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "novelty", 
                "description": "the input novelty"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "ratioThreshold": [
                "ratio threshold for peak-picking compared to novelty_signal/novelty_average, 0  disable it ,  for low energy onsets", 
                "\"[0,inf)16."
            ], 
            "frameRate": [
                "frameRate", 
                "\"(0,inf)172."
            ], 
            "combine": [
                "ms for onset combination", 
                "\"(0,inf)30."
            ], 
            "threshold": [
                "threshold for peak peaking compared to the difference of novelty_signal and average_signal ,  for peaking onsets in ambien noise", 
                "\",\"[0,inf)\",.05"
            ], 
            "pre_max": [
                "use N miliseconds past information for moving maximum", 
                "\"(0,inf)30."
            ], 
            "pre_avg": [
                "use N miliseconds past information for moving average", 
                "\"(0,inf)100."
            ]
        }, 
        "source": "algorithms/SuperFlux/SuperFlux/SuperFluxPeaks.cpp", 
        "outputs": {
            "_peaks": {
                "type": "std::vector<Real>", 
                "name": "peaks", 
                "description": "the input novelty"
            }
        }, 
        "header": "algorithms/SuperFlux/SuperFlux/SuperFluxPeaks.h", 
        "has_streaming": true
    }, 
    "Trimmer": {
        "inputs": {
            "_input": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the input audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "endTime": [
                "the end time of the slice you want to extract [s]", 
                "\"[0,inf)1.0e6"
            ], 
            "startTime": [
                "the start time of the slice you want to extract [s]", 
                "\"[0,inf)0.0"
            ]
        }, 
        "source": "algorithms/standard/trimmer.cpp", 
        "outputs": {
            "_output": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the trimmed signal"
            }
        }, 
        "header": "algorithms/standard/trimmer.h", 
        "has_streaming": true
    }, 
    "RingBufferVectorOutput": {
        "inputs": {
            "_input": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": false, 
        "parameters": {
            "bufferSize": [
                "size of the ringbuffer", 
                "\"8192"
            ]
        }, 
        "source": "algorithms/io/ringbuffervectoroutput.cpp", 
        "outputs": {}, 
        "header": "algorithms/io/ringbuffervectoroutput.h", 
        "has_streaming": true
    }, 
    "BpmRubato": {
        "inputs": {
            "_beats": {
                "type": "std::vector<Real>", 
                "name": "beats", 
                "description": "list of detected beat ticks [s]"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "shortRegionsMergingTime": [
                "time for the shortest constant tempo region from one tempo region to another [s]", 
                "\"[0,inf)4."
            ], 
            "tolerance": [
                "minimum tempo deviation to look for", 
                "\"[0,1]0.08"
            ], 
            "longRegionsPruningTime": [
                "time for the longest constant tempo region inside a rubato region [s]", 
                "\"[0,inf)20."
            ]
        }, 
        "source": "algorithms/rhythm/bpmrubato.cpp", 
        "outputs": {
            "_rubatoNumber": {
                "type": "int", 
                "name": "rubatoNumber", 
                "description": "number of detected rubato regions"
            }, 
            "_rubatoStart": {
                "type": "std::vector<Real>", 
                "name": "rubatoStart", 
                "description": "list of timestamps where the start of a rubato region was detected [s]"
            }, 
            "_rubatoStop": {
                "type": "std::vector<Real>", 
                "name": "rubatoStop", 
                "description": "list of timestamps where the end of a rubato region was detected [s]"
            }
        }, 
        "header": "algorithms/rhythm/bpmrubato.h", 
        "has_streaming": true
    }, 
    "SilenceRate": {
        "inputs": {
            "_frame": {
                "type": "std::vector<Real>", 
                "name": "frame", 
                "description": "the input frame"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "thresholds": [
                "the threshold values", 
                "\"std::vector<Real>()"
            ]
        }, 
        "source": "algorithms/standard/silencerate.cpp", 
        "outputs": {
            "_outputs": {
                "type": "Real>*", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/standard/silencerate.h", 
        "has_streaming": true
    }, 
    "TCToTotal": {
        "inputs": {
            "_envelope": {
                "type": "std::vector<Real>", 
                "name": "envelope", 
                "description": "the envelope of the signal (its length must be greater than 1"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/sfx/tctototal.cpp", 
        "outputs": {
            "_TCToTotal": {
                "type": "Real", 
                "name": "TCToTotal", 
                "description": "the temporal centroid to total length ratio"
            }
        }, 
        "header": "algorithms/sfx/tctototal.h", 
        "has_streaming": true
    }, 
    "PitchSalience": {
        "inputs": {
            "_spectrum": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the input audio spectrum"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "lowBoundary": [
                "from which frequency we are looking for the maximum (must not be larger than highBoundary) [Hz]", 
                "\"(0,inf)100.0"
            ], 
            "highBoundary": [
                "until which frequency we are looking for the minimum (must be smaller than half sampleRate) [Hz]", 
                "\"(0,inf)5000.0"
            ]
        }, 
        "source": "algorithms/sfx/pitchsalience.cpp", 
        "outputs": {
            "_pitchSalience": {
                "type": "Real", 
                "name": "pitchSalience", 
                "description": "the pitch salience (normalized from 0 to 1)"
            }
        }, 
        "header": "algorithms/sfx/pitchsalience.h", 
        "has_streaming": true
    }, 
    "UnaryOperator": {
        "inputs": {
            "_input": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "type": [
                "the type of the unary operator to apply to input array", 
                "\"{identity,abs,log10,log,ln,lin2db,db2lin,sin,cos,sqrt,square}\"identity\""
            ]
        }, 
        "source": "algorithms/standard/unaryoperator.cpp", 
        "outputs": {
            "_output": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array transformed by unary operation"
            }
        }, 
        "header": "algorithms/standard/unaryoperator.h", 
        "has_streaming": true
    }, 
    "Entropy": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "and must be non-empty)", 
                "description": "and must be non-empty)"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/stats/entropy.cpp", 
        "outputs": {
            "_entropy": {
                "type": "Real", 
                "name": "entropy", 
                "description": "the entropy of the input array"
            }
        }, 
        "header": "algorithms/stats/entropy.h", 
        "has_streaming": true
    }, 
    "RhythmTransform": {
        "inputs": {
            "_melBands": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "melBands", 
                "description": "the energy in the melbands"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "frameSize": [
                "the frame size to compute the rhythm trasform", 
                "\"(0,inf)256"
            ], 
            "hopSize": [
                "the hop size to compute the rhythm transform", 
                "\"(0,inf)32"
            ]
        }, 
        "source": "algorithms/rhythm/rhythmtransform.cpp", 
        "outputs": {
            "_rhythmTransform": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "rhythm", 
                "description": "consecutive frames in the rhythm domain"
            }
        }, 
        "header": "algorithms/rhythm/rhythmtransform.h", 
        "has_streaming": true
    }, 
    "FlatnessSFX": {
        "inputs": {
            "_envelope": {
                "type": "std::vector<Real>", 
                "name": "envelope", 
                "description": "the envelope of the signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/sfx/flatnesssfx.cpp", 
        "outputs": {
            "_flatnessSFX": {
                "type": "Real", 
                "name": "flatness", 
                "description": "the flatness coefficient"
            }
        }, 
        "header": "algorithms/sfx/flatnesssfx.h", 
        "has_streaming": true
    }, 
    "KeyExtractor": {
        "inputs": {
            "_audio": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "tuningFrequency": [
                "the tuning frequency of the input signal", 
                "\"(0,inf)440.0"
            ], 
            "frameSize": [
                "the framesize for computing tonal features", 
                "\"(0,inf)4096"
            ], 
            "hopSize": [
                "the hopsize for computing tonal features", 
                "\"(0,inf)2048"
            ]
        }, 
        "source": "algorithms/extractor/keyextractor.cpp", 
        "outputs": {
            "_keyStrength": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_keyScale": {
                "type": "std::string", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_keyKey": {
                "type": "std::string", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/extractor/keyextractor.h", 
        "has_streaming": true
    }, 
    "Median": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array (must be non-empty)"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/stats/median.cpp", 
        "outputs": {
            "_median": {
                "type": "Real", 
                "name": "median", 
                "description": "the median of the input array"
            }
        }, 
        "header": "algorithms/stats/median.h", 
        "has_streaming": true
    }, 
    "Flux": {
        "inputs": {
            "_spectrum": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the input spectrum"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "halfRectify": [
                "half-rectify the differences in each spectrum bin", 
                "\"{true,false}false"
            ], 
            "norm": [
                "the norm to use for difference computation", 
                "\"{L1,L2}\"L2\""
            ]
        }, 
        "source": "algorithms/spectral/flux.cpp", 
        "outputs": {
            "_flux": {
                "type": "Real", 
                "name": "flux", 
                "description": "the spectral flux of the input spectrum"
            }
        }, 
        "header": "algorithms/spectral/flux.h", 
        "has_streaming": true
    }, 
    "RawMoments": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "range": [
                "the range of the input array, used for normalizing the results", 
                "\"(0,inf)22050."
            ]
        }, 
        "source": "algorithms/stats/rawmoments.cpp", 
        "outputs": {
            "_rawMoments": {
                "type": "std::vector<Real>", 
                "name": "rawMoments", 
                "description": "the (raw) moments of the input array"
            }
        }, 
        "header": "algorithms/stats/rawmoments.h", 
        "has_streaming": true
    }, 
    "CrossCorrelation": {
        "inputs": {
            "_signal_y": {
                "type": "std::vector<Real>", 
                "name": "arrayY", 
                "description": "the second input array"
            }, 
            "_signal_x": {
                "type": "std::vector<Real>", 
                "name": "arrayX", 
                "description": "the first input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "minLag": [
                "the minimum lag to be computed between the two vectors", 
                "\"(-inf,inf)0"
            ], 
            "maxLag": [
                "the maximum lag to be computed between the two vectors", 
                "\"(-inf,inf)1"
            ]
        }, 
        "source": "algorithms/standard/crosscorrelation.cpp", 
        "outputs": {
            "_correlation": {
                "type": "std::vector<Real>", 
                "name": "crossCorrelation", 
                "description": "the cross-correlation vector between the two input arrays (its size is equal to maxLag - minLag + 1)"
            }
        }, 
        "header": "algorithms/standard/crosscorrelation.h", 
        "has_streaming": true
    }, 
    "FadeDetection": {
        "inputs": {
            "_rms": {
                "type": "std::vector<Real>", 
                "name": "rms", 
                "description": "rms values array"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "minLength": [
                "the minimum length to consider a fade-in/out [s]", 
                "\"(0,inf)3.0"
            ], 
            "cutoffLow": [
                "fraction of the average RMS to define the minimum threshold", 
                "\"[0,1)0.20"
            ], 
            "frameRate": [
                "the rate of frames used in calculation of the RMS [frames/s]", 
                "\"(0,inf)4.0"
            ], 
            "cutoffHigh": [
                "fraction of the average RMS to define the maximum threshold", 
                "\"(0,1]0.85"
            ]
        }, 
        "source": "algorithms/highlevel/fadedetection.cpp", 
        "outputs": {
            "_fade_in": {
                "type": "TNT::Array2D<Real>", 
                "name": "fadeIn", 
                "description": "2D-array containing start/stop timestamps corresponding to fade-ins [s] (ordered chronologically)"
            }, 
            "_fade_out": {
                "type": "TNT::Array2D<Real>", 
                "name": "fadeOut", 
                "description": "2D-array containing start/stop timestamps corresponding to fade-outs [s] (ordered chronologically)"
            }
        }, 
        "header": "algorithms/highlevel/fadedetection.h", 
        "has_streaming": true
    }, 
    "RingBufferInput": {
        "inputs": {}, 
        "has_standard": false, 
        "parameters": {
            "bufferSize": [
                "the size of the ringbuffer", 
                "\"8192"
            ]
        }, 
        "source": "algorithms/io/ringbufferinput.cpp", 
        "outputs": {
            "_output": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/io/ringbufferinput.h", 
        "has_streaming": true
    }, 
    "TempoScaleBands": {
        "inputs": {
            "_bands": {
                "type": "std::vector<Real>", 
                "name": "bands", 
                "description": "the audio power spectrum divided into bands"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "bandsGain": [
                "gain for each bands", 
                "\"arrayToVector<Real>(bandGains)"
            ], 
            "frameTime": [
                "the frame rate in samples", 
                "\"(0,inf)512.0"
            ]
        }, 
        "source": "algorithms/rhythm/temposcalebands.cpp", 
        "outputs": {
            "_cumulBands": {
                "type": "Real", 
                "name": "cumulativeBands", 
                "description": "cumulative sum of the output bands before scaling"
            }, 
            "_scaledBands": {
                "type": "std::vector<Real>", 
                "name": "scaledBands", 
                "description": "the output bands after scaling"
            }
        }, 
        "header": "algorithms/rhythm/temposcalebands.h", 
        "has_streaming": true
    }, 
    "SingleGaussian": {
        "inputs": {
            "_matrix": {
                "type": "TNT::Array2D<Real>", 
                "name": "matrix", 
                "description": "the input data matrix (e.g. the MFCC descriptor over frames)"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/stats/singlegaussian.cpp", 
        "outputs": {
            "_inverseCovariance": {
                "type": "TNT::Array2D<Real>", 
                "name": "inverseCovariance", 
                "description": "the inverse of the covariance matrix"
            }, 
            "_mean": {
                "type": "std::vector<Real>", 
                "name": "mean", 
                "description": "the mean of the values"
            }, 
            "_covariance": {
                "type": "TNT::Array2D<Real>", 
                "name": "covariance", 
                "description": "the covariance matrix"
            }
        }, 
        "header": "algorithms/stats/singlegaussian.h", 
        "has_streaming": true
    }, 
    "DynamicComplexity": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input audio signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "frameSize": [
                "the frame size [s]", 
                "\"(0,inf)0.2"
            ]
        }, 
        "source": "algorithms/highlevel/dynamiccomplexity.cpp", 
        "outputs": {
            "_complexity": {
                "type": "Real", 
                "name": "dynamicComplexity", 
                "description": "the dynamic complexity coefficient"
            }, 
            "_loudness": {
                "type": "Real", 
                "name": "loudness", 
                "description": "an estimate of the loudness [dB]"
            }
        }, 
        "header": "algorithms/highlevel/dynamiccomplexity.h", 
        "has_streaming": true
    }, 
    "Mean": {
        "inputs": {
            "_array": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/stats/mean.cpp", 
        "outputs": {
            "_mean": {
                "type": "Real", 
                "name": "mean", 
                "description": "the mean of the input array"
            }
        }, 
        "header": "algorithms/stats/mean.h", 
        "has_streaming": true
    }, 
    "Extractor": {
        "inputs": {
            "*, Pool&)": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "audio", 
                "description": "the input audio signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "tonalFrameSize": [
                "the frame size for low level tonal features", 
                "\"(0,inf)4096 "
            ], 
            "dynamicsHopSize": [
                "the hop size for level dynamics", 
                "\"(0,inf)44100"
            ], 
            "tuning": [
                "compute tuning frequency", 
                "\"{true,false}true"
            ], 
            "relativeIoi": [
                "compute relative inter onset intervals", 
                "\"{true,false}false"
            ], 
            "namespace": [
                "the main namespace under which to store the results", 
                "\"\"\""
            ], 
            "lowLevelFrameSize": [
                "the frame size for computing low level features", 
                "\"(0,inf)2048"
            ], 
            "lowLevelHopSize": [
                "the hop size for computing low level features", 
                "\"(0,inf)1024"
            ], 
            "midLevel": [
                "compute mid level features", 
                "\"{true,false}true"
            ], 
            "rhythm": [
                "compute rhythm features", 
                "\"{true,false}true"
            ], 
            "lowLevel": [
                "compute low level features", 
                "\"{true,false}true"
            ], 
            "sampleRate": [
                "the audio sampling rate", 
                "\"(0,inf)44100.0"
            ], 
            "dynamicsFrameSize": [
                "the frame size for level dynamics", 
                "\"(0,inf)88200"
            ], 
            "dynamics": [
                "compute dynamics' features", 
                "\"{true,false}true"
            ], 
            "tonalHopSize": [
                "the hop size for low level tonal features", 
                "\"(0,inf)2048"
            ], 
            "highLevel": [
                "compute high level features", 
                "\"{true,false}true"
            ]
        }, 
        "source": "algorithms/extractor/extractor.cpp", 
        "outputs": {
            "_pool": {
                "type": "Pool", 
                "name": "pool", 
                "description": "the pool where to store the results"
            }
        }, 
        "header": "algorithms/extractor/extractor.h", 
        "has_streaming": false
    }, 
    "UnaryOperatorStream": {
        "inputs": {
            "_input": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "shift": [
                "shift result by value (add value)", 
                "\"(-inf,inf)0."
            ], 
            "scale": [
                "multiply result by factor", 
                "\"(-inf,inf)1."
            ], 
            "type": [
                "the type of the unary operator to apply to input array", 
                "\"{identity,abs,log10,log,ln,lin2db,db2lin,sin,cos,sqrt,square}\"identity\""
            ]
        }, 
        "source": "algorithms/standard/unaryoperatorstream.cpp", 
        "outputs": {
            "_output": {
                "type": "std::vector<Real>", 
                "name": "array", 
                "description": "the input array transformed by unary operation"
            }
        }, 
        "header": "algorithms/standard/unaryoperatorstream.h", 
        "has_streaming": true
    }, 
    "NoveltyCurveFixedBpmEstimator": {
        "inputs": {
            "_novelty": {
                "type": "std::vector<Real>", 
                "name": "novelty", 
                "description": "the novelty curve of the audio signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate original audio signal [Hz]", 
                "\"[1,inf)44100."
            ], 
            "maxBpm": [
                "the maximum bpm to look for", 
                "\"(0,inf)560.0"
            ], 
            "tolerance": [
                "tolerance (in percentage) for considering bpms to be equal", 
                "\"(0,100]3.0"
            ], 
            "hopSize": [
                "the hopSize used to computeh the novelty curve from the original signal", 
                "\"512"
            ], 
            "minBpm": [
                "the minimum bpm to look for", 
                "\"(0,inf)30.0"
            ]
        }, 
        "source": "algorithms/rhythm/noveltycurvefixedbpmestimator.cpp", 
        "outputs": {
            "_bpmAmplitudes": {
                "type": "std::vector<Real>", 
                "name": "amplitudes", 
                "description": "the magnitude of each bpm candidate"
            }, 
            "_bpmPositions": {
                "type": "std::vector<Real>", 
                "name": "bpms", 
                "description": "the bpm candidates sorted by magnitude"
            }
        }, 
        "header": "algorithms/rhythm/noveltycurvefixedbpmestimator.h", 
        "has_streaming": false
    }, 
    "ChordsDetection": {
        "inputs": {
            "_pcp": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "pcp", 
                "description": "the pitch class profile from which to detect the chord"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "windowSize": [
                "the size of the window on which to estimate the chords [s]", 
                "\"(0,inf)2.0"
            ], 
            "hopSize": [
                "the hop size with which the input PCPs were computed", 
                "\"(0,inf)2048"
            ]
        }, 
        "source": "algorithms/tonal/chordsdetection.cpp", 
        "outputs": {
            "_chords": {
                "type": "std::vector<std::string>", 
                "name": "from A to G", 
                "description": "from A to G"
            }, 
            "_strength": {
                "type": "std::vector<Real>", 
                "name": "strength", 
                "description": "the strength of the chord"
            }
        }, 
        "header": "algorithms/tonal/chordsdetection.h", 
        "has_streaming": true
    }, 
    "PitchYin": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal frame"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "minFrequency": [
                "the minimum allowed frequency [Hz]", 
                "\"(0,inf)20.0"
            ], 
            "frameSize": [
                "number of samples in the input frame", 
                "\"[2,inf)2048"
            ], 
            "maxFrequency": [
                "the maximum allowed frequency [Hz]", 
                "\"(0,inf)22050.0"
            ], 
            "interpolate": [
                "enable interpolation", 
                "\"{true,false}true"
            ], 
            "sampleRate": [
                "sampling rate of the input spectrum [Hz]", 
                "\"(0,inf)44100."
            ], 
            "tolerance": [
                "tolerance for peak detection", 
                "\"[0,1]0.15"
            ]
        }, 
        "source": "algorithms/tonal/pitchyin.cpp", 
        "outputs": {
            "_pitch": {
                "type": "Real", 
                "name": "pitch", 
                "description": "detected pitch [Hz]"
            }, 
            "_pitchConfidence": {
                "type": "Real", 
                "name": "1]", 
                "description": "1]"
            }
        }, 
        "header": "algorithms/tonal/pitchyin.h", 
        "has_streaming": true
    }, 
    "MFCC": {
        "inputs": {
            "_spectrum": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the audio spectrum"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "inputSize": [
                "the size of input spectrum", 
                "\"(1,inf)1025"
            ], 
            "numberBands": [
                "the number of mel-bands in the filter", 
                "\"[1,inf)40"
            ], 
            "lowFrequencyBound": [
                "the lower bound of the frequency range [Hz]", 
                "\"[0,inf)0."
            ], 
            "numberCoefficients": [
                "the number of output mel coefficients", 
                "\"[1,inf)13"
            ], 
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ], 
            "highFrequencyBound": [
                "the upper bound of the frequency range [Hz]", 
                "\"(0,inf)11000."
            ]
        }, 
        "source": "algorithms/spectral/mfcc.cpp", 
        "outputs": {
            "_bands": {
                "type": "std::vector<Real>", 
                "name": "bands", 
                "description": "the energies in mel bands"
            }, 
            "_mfcc": {
                "type": "std::vector<Real>", 
                "name": "mfcc", 
                "description": "the mel frequency cepstrum coefficients"
            }
        }, 
        "header": "algorithms/spectral/mfcc.h", 
        "has_streaming": true
    }, 
    "NoveltyCurve": {
        "inputs": {
            "_frequencyBands": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "frequencyBands", 
                "description": "the frequency bands"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "normalize": [
                "whether to normalize each band's energy", 
                "\"{true,false}false"
            ], 
            "weightCurve": [
                "vector containing the weights for each frequency band. Only if weightCurveType==supplied", 
                "\"std::vector<Real>(0)"
            ], 
            "frameRate": [
                "the sampling rate of the input audio", 
                "\"[1,inf)44100./128."
            ], 
            "weightCurveType": [
                "the type of weighting to be used for the bands novelty", 
                "\",\"{flat,triangle,inverse_triangle,parabola,inverse_parabola,linear,quadratic,inverse_quadratic,supplied}\""
            ]
        }, 
        "source": "algorithms/rhythm/noveltycurve.cpp", 
        "outputs": {
            "_novelty": {
                "type": "std::vector<Real>", 
                "name": "novelty", 
                "description": "the novelty curve as a single vector"
            }
        }, 
        "header": "algorithms/rhythm/noveltycurve.h", 
        "has_streaming": true
    }, 
    "Spectrum": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "frame", 
                "description": "the input audio frame"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "size": [
                "the expected size of the input audio signal (this is an optional parameter to optimize memory allocation)", 
                "\"[1,inf)2048"
            ]
        }, 
        "source": "algorithms/standard/spectrum.cpp", 
        "outputs": {
            "_spectrum": {
                "type": "std::vector<Real>", 
                "name": "spectrum", 
                "description": "the magnitude spectrum of the input audio signal"
            }
        }, 
        "header": "algorithms/standard/spectrum.h", 
        "has_streaming": true
    }, 
    "TempoTapMaxAgreement": {
        "inputs": {
            "_tickCandidates": {
                "type": "std::vector<std::vector<Real> >", 
                "name": "tickCandidates", 
                "description": "the tick candidates estimated using different beat trackers (or features) [s]"
            }
        }, 
        "has_standard": true, 
        "parameters": {}, 
        "source": "algorithms/rhythm/tempotapmaxagreement.cpp", 
        "outputs": {
            "_confidence": {
                "type": "Real", 
                "name": "5.32]", 
                "description": "5.32]"
            }, 
            "_ticks": {
                "type": "std::vector<Real>", 
                "name": "ticks", 
                "description": "the list of resulting ticks [s]"
            }
        }, 
        "header": "algorithms/rhythm/tempotapmaxagreement.h", 
        "has_streaming": true
    }, 
    "PowerSpectrum": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "size": [
                "the expected size of the input frame (this is purely optional and only targeted at optimizing the creation time of the FFT object)", 
                "\"[1,inf)1024"
            ]
        }, 
        "source": "algorithms/standard/powerspectrum.cpp", 
        "outputs": {
            "_powerSpectrum": {
                "type": "std::vector<Real>", 
                "name": "powerSpectrum", 
                "description": "the power spectrum of the input signal"
            }
        }, 
        "header": "algorithms/standard/powerspectrum.h", 
        "has_streaming": true
    }, 
    "Duration": {
        "inputs": {
            "_signal": {
                "type": "std::vector<Real>", 
                "name": "signal", 
                "description": "the input signal"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "sampleRate": [
                "the sampling rate of the audio signal [Hz]", 
                "\"(0,inf)44100."
            ]
        }, 
        "source": "algorithms/temporal/duration.cpp", 
        "outputs": {
            "_duration": {
                "type": "Real", 
                "name": "duration", 
                "description": "the duration of the signal [s]"
            }
        }, 
        "header": "algorithms/temporal/duration.h", 
        "has_streaming": true
    }, 
    "CubicSpline": {
        "inputs": {
            "_xInput": {
                "type": "Real", 
                "name": "x", 
                "description": "the input coordinate (x-axis)"
            }
        }, 
        "has_standard": true, 
        "parameters": {
            "leftBoundaryValue": [
                "the value to be used in the left boundary, when leftBoundaryFlag is 1 or 2", 
                "\"(-inf,inf)0.0"
            ], 
            "yPoints": [
                "the y-coordinates to be interpolated (i.e. the known data)", 
                "\"defaultPoints"
            ], 
            "rightBoundaryFlag": [
                "type of boundary condition for the right boundary", 
                "\"{0,1,2}0"
            ], 
            "rightBoundaryValue": [
                "the value to be used in the right boundary, when rightBoundaryFlag is 1 or 2", 
                "\"(-inf,inf)0.0"
            ], 
            "xPoints": [
                "the x-coordinates where data is specified (the points must be arranged in ascending order and cannot contain duplicates)", 
                "\"defaultPoints"
            ], 
            "leftBoundaryFlag": [
                "type of boundary condition for the left boundary", 
                "\"{0,1,2}0"
            ]
        }, 
        "source": "algorithms/standard/cubicspline.cpp", 
        "outputs": {
            "_ddyOutput": {
                "type": "Real", 
                "name": "ddy", 
                "description": "the second derivative of the spline at x"
            }, 
            "_yOutput": {
                "type": "Real", 
                "name": "y", 
                "description": "the value of the spline at x"
            }, 
            "_dyOutput": {
                "type": "Real", 
                "name": "dy", 
                "description": "the first derivative of the spline at x"
            }
        }, 
        "header": "algorithms/standard/cubicspline.h", 
        "has_streaming": true
    }, 
    "BarkExtractor": {
        "inputs": {
            "_signal": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "has_standard": false, 
        "parameters": {
            "sampleRate": [
                "the audio sampling rate", 
                "\"(0,inf)44100.0"
            ], 
            "frameSize": [
                "the frame size for computing low level features", 
                "\"(0,inf)2048"
            ], 
            "hopSize": [
                "the hop size for computing low level features", 
                "\"(0,inf)1024"
            ]
        }, 
        "source": "algorithms/extractor/barkextractor.cpp", 
        "outputs": {
            "_bbandsSkewness": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_crestValue": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_bbands": {
                "type": "std::vector<Real>", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_bbandsSpread": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_bbandsKurtosis": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }, 
            "_flatness": {
                "type": "Real", 
                "name": "Unknown", 
                "description": "TODO"
            }
        }, 
        "header": "algorithms/extractor/barkextractor.h", 
        "has_streaming": true
    }
}