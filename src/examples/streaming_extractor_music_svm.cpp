/*
 * Copyright (C) 2006-2013  Music Technology Group - Universitat Pompeu Fabra
 *
 * This file is part of Essentia
 *
 * Essentia is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation (FSF), either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the Affero GNU General Public License
 * version 3 along with this program.  If not, see http://www.gnu.org/licenses/
 */

// Streaming extractor designed for high-level (classifier-based) analysis of
// music collections.

//#include <essentia/streaming/algorithms/poolstorage.h>
//#include <essentia/essentiautil.h>
#include "essentia/algorithm.h"
#include "essentia/algorithmfactory.h"
#include "essentia/pool.h"
#include "extractor_music/MusicExtractor.h"
#include <gaia2/gaia.h>

using namespace std;
using namespace essentia;
using namespace essentia::standard;

void usage(char *progname) {
    cout << "Error: wrong number of arguments" << endl;
    cout << "Usage: " << progname << " input_descriptorfile output_textfile> [profile]" << endl;
    cout << endl <<
"This extractor generates semantic annotation of music in terms of genres, mood,\n"
"type of rhythm, and instrumentation qualities, using a set of pretrained SVM\n"
"classifiers. It expects a json/yaml file generated by 'streaming_extractor_music'\n"
"extractor as its input" << endl;
    cout << endl << "Music extractor version '" << EXTRACTOR_VERSION << "'" << endl 
         << "built with Essentia version " << essentia::version_git_sha << endl;

    exit(1);
}

int main(int argc, char* argv[]) {
  // Returns: 1 on essentia error

  string descriptorsFilename, outputFilename, profileFilename;

  switch (argc) {
    case 3:
      descriptorsFilename =  argv[1];
      outputFilename = argv[2];
      break;
    case 4: // profile supplied
      descriptorsFilename =  argv[1];
      outputFilename = argv[2];
      profileFilename = argv[3];
      break;
    default:
      usage(argv[0]);
  }

  try {
    essentia::init();

    cout.precision(10); // TODO ????

    MusicExtractor *extractor = new MusicExtractor();
    extractor->setExtractorOptions(profileFilename);

    string format = extractor->options.value<string>("highlevel.inputFormat");
    if (format != "json" && format != "yaml") {
      cerr << "incorrect format specified: " << format << endl;
      return 1;
    }

    Pool pool;
    // load descriptor file
    essentia::standard::AlgorithmFactory& factory = essentia::standard::AlgorithmFactory::instance();
    essentia::standard::Algorithm* yamlInput = factory.create("YamlInput",
                                                              "filename", descriptorsFilename,
                                                              "format", format);
    yamlInput->output("pool").set(pool);
    yamlInput->compute();

    // apply SVM models and save
    extractor->computeSVMDescriptors(pool);

    pool.removeNamespace("lowlevel");
    pool.removeNamespace("rhythm");
    pool.removeNamespace("tonal");

    vector<string> keys = pool.descriptorNames("metadata.version");
    for (int i=0; i<(int) keys.size(); ++i) {
        string k = keys[i];
        string newk = "metadata.version.lowlevel." + k.substr(17);
        pool.set(newk, pool.value<string>(keys[i]));
        pool.remove(keys[i]);
    }

    pool.set("metadata.version.highlevel.essentia", essentia::version);
    pool.set("metadata.version.highlevel.essentia_git_sha", essentia::version_git_sha);
    pool.set("metadata.version.highlevel.extractor", EXTRACTOR_VERSION);
    pool.set("metadata.version.highlevel.gaia", gaia2::version);
    pool.set("metadata.version.highlevel.gaia_git_sha", gaia2::version_git_sha);

    extractor->mergeValues(pool);
    extractor->outputToFile(pool, outputFilename);

    essentia::shutdown();
  }
  catch (EssentiaException& e) {
    cout << e.what() << endl;
    return 1;
  }
  return 0;
}
